[{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://robindenz1.github.io/MatchTime/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://robindenz1.github.io/MatchTime/articles/creating_start_stop_data.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Creating and Dealing with Start-Stop Data in R","text":"common task survival analysis, types analyses involve time-varying covariates, creation start-stop datasets. datasets include multiple intervals per subject case, along one multiple covariate values correspond value observed defined time-intervals. MatchTime package offers wide range functions create transform datasets data sources (mostly also required input main function, match_time()). goal functions make easy create valid start-stop datasets process existing ones, even millions cases /large amount intervals. current standard tool create start-stop data tmerge() function survival package, originally meant handle large datasets. contrast, implementations offered rely exclusively code written using data.table back-end, making faster RAM efficient. Additionally, functions included MatchTime work well incomplete information, often occurs real data.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/articles/creating_start_stop_data.html","id":"covariates","dir":"Articles","previous_headings":"What is Start-Stop Data?","what":"Covariates","title":"Creating and Dealing with Start-Stop Data in R","text":"First, let’s little clear exactly constitutes start-stop dataset. Consider following example: dataset shown consists two individuals (two distinct id values) multiple recorded time-intervals (defined start stop columns). Additionally, includes information sex bmi (Body-Mass-Index) individual. concrete example, individual 1 considered male (sex=\"m\") individual 2 considered female (sex=\"f\") entire observed duration. words, sex time-fixed time-constant variable. hand, two individuals multiple different values bmi column, making time-varying time-dependent variable. specifically, say value bmi individual 1 32 t=0t = 0 t=10t = 10. Afterwards changed 34 stayed value t=50t = 50. , start value included interval, stop value excluded. type coding known right-open left-closed intervals (start value considered interval, stop value ). usually denoted [start, stop) usual way intervals coded time--event purposes. Throughout package rely exclusively type intervals. Note reality values time-dependent variables necessarily change instantaneously. allow data representation however necessary define intervals value stays constant. width intervals usually dependent type data one access .","code":"library(data.table) library(MatchTime)  data <- data.table(id=c(1, 1, 1, 2, 2, 2, 2),                    start=c(0, 10, 50, 0, 28, 120, 125),                    stop=c(10, 50, 112, 28, 120, 125, 213),                    sex=c(\"m\", \"m\", \"m\", \"f\", \"f\", \"f\", \"f\"),                    bmi=c(32, 34, 38, 27, 28, 35, 26)) print(data) ##       id start  stop    sex   bmi ##    <num> <num> <num> <char> <num> ## 1:     1     0    10      m    32 ## 2:     1    10    50      m    34 ## 3:     1    50   112      m    38 ## 4:     2     0    28      f    27 ## 5:     2    28   120      f    28 ## 6:     2   120   125      f    35 ## 7:     2   125   213      f    26"},{"path":"https://robindenz1.github.io/MatchTime/articles/creating_start_stop_data.html","id":"outcomes","dir":"Articles","previous_headings":"What is Start-Stop Data?","what":"Outcomes","title":"Creating and Dealing with Start-Stop Data in R","text":"addition time-fixed time-dependent variables usually also need consider outcomes. classic start-stop datasets, outcomes usually either binary categorical indicators event (possibly type) occurring specific points time. sort events need coded slightly differently standard time-dependent variables. give example dataset shown earlier, additional event column added , contains binary outcome event indicator: main difference coding time-varying variables outcome events intervals always reflect time durations covariates stay constant, events instead coded occur exactly end interval. essence, existing intervals simply broken two single event happens . terminal events, death, observation period ends first event. dataset , id = 1 example phenomenon. individual experiences event 112, data afterwards. example recurrent events given id = 2. person experiences event t=35t = 35 t=127t = 127. can seen data, although neither sex bmi changed t=28t = 28 t=120t = 120, interval broken two rows show event occurred t=35t = 35. use right-open intervals covariates, events always coded occur exactly stop value. directly use sort data fit Cox proportional hazards regression model time-dependent covariates, using following syntax: Note case outcome entirely nonsensical, data made two individuals , overall structure exactly required coxph() call (match_time() call).","code":"data <- data.table(id=c(1, 1, 1, 2, 2, 2, 2, 2, 2),                    start=c(0, 10, 50, 0, 28, 35, 120, 125, 127),                    stop=c(10, 50, 112, 28, 35, 120, 125, 127, 213),                    sex=c(\"m\", \"m\", \"m\", \"f\", \"f\", \"f\", \"f\", \"f\", \"f\"),                    bmi=c(32, 34, 38, 27, 28, 28, 35, 26, 26),                    event=c(0, 0, 1, 0, 1, 0, 0, 1, 0)) print(data) ##       id start  stop    sex   bmi event ##    <num> <num> <num> <char> <num> <num> ## 1:     1     0    10      m    32     0 ## 2:     1    10    50      m    34     0 ## 3:     1    50   112      m    38     1 ## 4:     2     0    28      f    27     0 ## 5:     2    28    35      f    28     1 ## 6:     2    35   120      f    28     0 ## 7:     2   120   125      f    35     0 ## 8:     2   125   127      f    26     1 ## 9:     2   127   213      f    26     0 library(survival)  model <- coxph(Surv(start, stop, event) ~ bmi + sex, data=data) summary(model) ## Call: ## coxph(formula = Surv(start, stop, event) ~ bmi + sex, data = data) ##  ##   n= 9, number of events= 3  ##  ##            coef  exp(coef)   se(coef)      z Pr(>|z|) ## bmi   1.060e+01  4.019e+04  1.421e+04  0.001    0.999 ## sexm -8.481e+01  1.468e-37  1.172e+05 -0.001    0.999 ##  ##      exp(coef) exp(-coef) lower .95 upper .95 ## bmi  4.019e+04  2.488e-05         0       Inf ## sexm 1.468e-37  6.811e+36         0       Inf ##  ## Concordance= 1  (se = 0 ) ## Likelihood ratio test= 2.77  on 2 df,   p=0.3 ## Wald test            = 0  on 2 df,   p=1 ## Score (logrank) test = 2  on 2 df,   p=0.4"},{"path":"https://robindenz1.github.io/MatchTime/articles/creating_start_stop_data.html","id":"overview-of-included-functions","dir":"Articles","previous_headings":"","what":"Overview of Included Functions","title":"Creating and Dealing with Start-Stop Data in R","text":"following functions MatchTime may used deal start-stop data: merge_start_stop(): Merges two start-stop datasets subset_start_stop(): Takes subset intervals start-stop dataset simplify_start_stop(): Combines rows start-stop dataset possible fill_gaps_start_stop(): Adds missing time-intervals “incomplete” start-stop datasets start_stop2long(): Creates long-format dataset start-stop dataset long2start_stop(): Creates start-stop dataset long-format dataset times_from_start_stop(): Extracts specific “event” times start-stop dataset complete long-format dataset already exists, easiest way obtain start-stop dataset use long2start_stop() function. , however, works discrete-time data feasibly alternative full long-format data small enough fit available RAM, always case. users need merge_start_stop() function create single start-stop dataset different datasets containing time-dependent information. function advantage blow dataset long-format, making feasible create start-stop data large datasets. , advanced, functions useful dealing messy real-world data.","code":""},{"path":"https://robindenz1.github.io/MatchTime/articles/creating_start_stop_data.html","id":"the-merge_start_stop-function","dir":"Articles","previous_headings":"","what":"The merge_start_stop() function","title":"Creating and Dealing with Start-Stop Data in R","text":"important function create start-stop data included package merge_start_stop() function. ’ main purpose merge two datasets contain information time-intervals. Suppose following information treatment status multiple individuals: dataset already start-stop format, contains information treatment status individual. Note treatment coded (0 = treatment absent, 1 = treatment present). example, id = 1 received treatment 16-21 27-101 , id = 2 received treatment interval 12-66. Imagine also information additional time-dependent covariate, individuals place residence (denoted region), also start-stop format,: dataset, individual id = 2 moved (B t=20t = 20). Finally, another dataset includes time death individuals, known died: goal now combine different datasets single start-stop dataset. can done using following merge_start_stop() call: function call, supplied datasets containing time-dependent variables x y argument, passed dataset containing outcome events (death) event_times argument instead. events usually coded differently time-dependent covariates, described earlier. surface, merge_start_stop() combine (e.g. merge) different start-stop datasets. fact . However, also needs done order create useful start-stop datasets. users create datasets time-dependent variable (groups ) combine afterwards. illustrate little depth.","code":"d_treat <- data.table(id=c(1, 1, 1, 1, 2, 2, 3, 3, 4, 4),                       start=c(0, 16, 21, 27, 0, 12, 0, 2, 0, 3),                       stop=c(16, 21, 27, 101, 12, 66, 2, 98, 3, 88),                       treatment=c(0, 1, 0, 1, 0, 1, 1, 0, 1, 0)) print(d_treat) ##        id start  stop treatment ##     <num> <num> <num>     <num> ##  1:     1     0    16         0 ##  2:     1    16    21         1 ##  3:     1    21    27         0 ##  4:     1    27   101         1 ##  5:     2     0    12         0 ##  6:     2    12    66         1 ##  7:     3     0     2         1 ##  8:     3     2    98         0 ##  9:     4     0     3         1 ## 10:     4     3    88         0 d_region <- data.table(id=c(1, 2, 2, 3, 4),                        start=c(0, 0, 20, 0, 0),                        stop=c(101, 20, 66, 98, 88),                        region=c(\"A\", \"B\", \"A\", \"C\", \"D\")) print(d_region) ##       id start  stop region ##    <num> <num> <num> <char> ## 1:     1     0   101      A ## 2:     2     0    20      B ## 3:     2    20    66      A ## 4:     3     0    98      C ## 5:     4     0    88      D d_death <- data.table(id=c(1, 3),                       time=c(101, 98)) print(d_death) ##       id  time ##    <num> <num> ## 1:     1   101 ## 2:     3    98 d_out <- merge_start_stop(d_treat, d_region,                           by=\"id\",                           start=\"start\",                           stop=\"stop\",                           event_times=d_death,                           time_to_first_event=TRUE) print(d_out) ## Key: <id> ##        id start  stop region treatment status ##     <num> <num> <num> <char>     <num> <lgcl> ##  1:     1     0    16      A         0  FALSE ##  2:     1    16    21      A         1  FALSE ##  3:     1    21    27      A         0  FALSE ##  4:     1    27   101      A         1   TRUE ##  5:     2     0    12      B         0  FALSE ##  6:     2    12    20      B         1  FALSE ##  7:     2    20    66      A         1  FALSE ##  8:     3     0     2      C         1  FALSE ##  9:     3     2    98      C         0   TRUE ## 10:     4     0     3      D         1  FALSE ## 11:     4     3    88      D         0  FALSE"},{"path":"https://robindenz1.github.io/MatchTime/articles/creating_start_stop_data.html","id":"generating-start-stop-datasets-from-scratch","dir":"Articles","previous_headings":"","what":"Generating Start-Stop Datasets from Scratch","title":"Creating and Dealing with Start-Stop Data in R","text":"preceeding section, gave small example combining different datasets already start-stop format . section, relax assumption considering less structured input.","code":""},{"path":"https://robindenz1.github.io/MatchTime/articles/creating_start_stop_data.html","id":"the-input","dir":"Articles","previous_headings":"Generating Start-Stop Datasets from Scratch","what":"The Input","title":"Creating and Dealing with Start-Stop Data in R","text":"many cases information included desired start-stop dataset stored different tables already start-stop format . example, suppose interested creating start-stop dataset including information bmi, sex, birthyear chemo-therapy status different individuals time. Suppose following three datasets: example three datasets contain information two fictional individuals, id = 1 id = 2. dataset d_demographics contains time-constant information individual (sex birthyear). dataset d_bmi hand, consists bmi measurements person taken specific point time. Similarly, d_chemo dataset includes time person received chemotherapy. generate start-stop dataset three tables, make decisions resulting dataset look like. Based decisions, need augment little bit can use functions included package. general course action : 1.) Define singular start-stop datasets time-varying variable 2.) Merge together using merge_start_stop() points explained detail .","code":"d_demographics <- data.table(id=c(1, 2),                              sex=c(\"m\", \"f\"),                              birthyear=c(1954, 1962)) print(d_demographics) ##       id    sex birthyear ##    <num> <char>     <num> ## 1:     1      m      1954 ## 2:     2      f      1962 d_bmi <- data.table(id=c(1, 1, 1, 2, 2),                     start=c(25, 190, 256, 78, 235),                     bmi=c(41, 37, 32, 39, 31)) print(d_bmi) ##       id start   bmi ##    <num> <num> <num> ## 1:     1    25    41 ## 2:     1   190    37 ## 3:     1   256    32 ## 4:     2    78    39 ## 5:     2   235    31 d_chemo <- data.table(id=c(1, 2),                       start=c(112, 82)) print(d_chemo) ##       id start ##    <num> <num> ## 1:     1   112 ## 2:     2    82"},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/articles/creating_start_stop_data.html","id":"bmi","dir":"Articles","previous_headings":"Generating Start-Stop Datasets from Scratch > Defining Time-Intervals for each Time-Varying Variable","what":"BMI","title":"Creating and Dealing with Start-Stop Data in R","text":"first question need ask : interpolate bmi measurements? Since took measurements specific times, don’t actually know value bmi measurements. case simply assume value stayed constant next measurement (usually done practice). Given decision, create time-intervals define respective bmi value applies. conveniently already named time variable start make little obvious. can done three steps. 1.) Sort dataset id time Using data.table package, can done like (although already sorted example): 2.) Shift time variable Next use data.table package shift time variable one row per id, creating stop column: 3.) Deal last row step 2 able create stop value row per person, except last one. question case , long can last measured value bmi expected valid? many cases administrative end follow-can serve define point time. cases assumptions may reasonable. neither options work, might best just remove rows. example consider final follow-time t=500t = 500: result looks like : Essentially, now start-stop dataset , exactly goal exercise. start-stop datasets time-varying variable, can simply merge using merge_start_stop() function. Note may also valid choice “flip” intervals. case coded intervals start 0 (t) stay first observed value bmi t=25t = 25 id = 1. option choose might serious consequences, depends entirely kind data dealing .","code":"setkey(d_bmi, id, start) d_bmi[, stop := shift(start, type=\"lead\"), by=id] d_bmi[is.na(stop), stop := 500] print(d_bmi) ## Key: <id, start> ##       id start   bmi  stop ##    <num> <num> <num> <num> ## 1:     1    25    41   190 ## 2:     1   190    37   256 ## 3:     1   256    32   500 ## 4:     2    78    39   235 ## 5:     2   235    31   500"},{"path":"https://robindenz1.github.io/MatchTime/articles/creating_start_stop_data.html","id":"chemo","dir":"Articles","previous_headings":"Generating Start-Stop Datasets from Scratch > Defining Time-Intervals for each Time-Varying Variable","what":"Chemo","title":"Creating and Dealing with Start-Stop Data in R","text":"next question need answer : kind chemo variable need? unlimited variety options . , example, interested sort variable includes information “received chemo last x time units”. exemplary purposes first produce variable simply states whether someone received chemo last 100 time units. can done defining fitting stop column: now created start-stop dataset . Secondly, define value variable condition met. use something like \"yes\" 1, simplest (memory efficient) approach use TRUE. Since mini start-stop dataset includes rows condition met, can simple set entire column value: resulting dataset looks like : Note need change d_demographics dataset, contain time-varying information.","code":"d_chemo[, stop := start + 100] d_chemo[, chemo := TRUE] print(d_chemo) ##       id start  stop  chemo ##    <num> <num> <num> <lgcl> ## 1:     1   112   212   TRUE ## 2:     2    82   182   TRUE"},{"path":"https://robindenz1.github.io/MatchTime/articles/creating_start_stop_data.html","id":"merging-the-time-intervals-for-each-time-varying-variable","dir":"Articles","previous_headings":"Generating Start-Stop Datasets from Scratch","what":"Merging the Time-Intervals for each Time-Varying Variable","title":"Creating and Dealing with Start-Stop Data in R","text":"left call merge_start_stop() function , well, merge time-intervals bmi chemo. following function call may used: , simply supply variable-specific start-stop datasets first set argument person identifier. Additionally, set defaults argument list(chemo=FALSE), essentially tells merge_start_stop() function value chemo column FALSE time-intervals outside ones defined d_chemo dataset. Additionally, since information d_demographics time-independent, supplied constant_vars argument.","code":"out <- merge_start_stop(d_chemo, d_bmi, by=\"id\",                         defaults=list(chemo=FALSE),                         constant_vars=d_demographics) print(out) ## Key: <id> ##       id start  stop   bmi  chemo    sex birthyear ##    <num> <num> <num> <num> <lgcl> <char>     <num> ## 1:     1    25   112    41  FALSE      m      1954 ## 2:     1   112   190    41   TRUE      m      1954 ## 3:     1   190   212    37   TRUE      m      1954 ## 4:     1   212   256    37  FALSE      m      1954 ## 5:     1   256   500    32  FALSE      m      1954 ## 6:     2    78    82    39  FALSE      f      1962 ## 7:     2    82   182    39   TRUE      f      1962 ## 8:     2   182   235    39  FALSE      f      1962 ## 9:     2   235   500    31  FALSE      f      1962"},{"path":"https://robindenz1.github.io/MatchTime/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robin Denz. Author, maintainer.","code":""},{"path":"https://robindenz1.github.io/MatchTime/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Denz R (2025). MatchTime: Matching Causal Inference Time-Dependent Treatments. R package version 0.1.0, https://github.com/RobinDenz1/MatchTime.","code":"@Manual{,   title = {MatchTime: Matching for Causal Inference with Time-Dependent Treatments},   author = {Robin Denz},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/RobinDenz1/MatchTime}, }"},{"path":"https://robindenz1.github.io/MatchTime/index.html","id":"matchtime-","dir":"","previous_headings":"","what":"Matching for Causal Inference with Time-Dependent Treatments","title":"Matching for Causal Inference with Time-Dependent Treatments","text":"MatchTime R-Package can used perform different sorts time-dependent matching, also known sequential trial emulation. type matching, treatment, outcome, confounders allowed change time. point time individuals switch “untreated” “treated”, controls point time still “untreated” matched individuals using standard matching methods. point time matching occurred considered “point randomization” “time-zero” cases matched controls. result dataset can analyzed using standard time--event methods, simple Cox proportional-hazards regression models, even complex forms time-dependent confounding treatment-confounder feedback present data. package designed similar possible excellent MatchIt package, implements direct support matching separate point time. supports treatment covariate changes discrete continuous time requiring user input start-stop data. generating dealing start-stop data can difficult, also implements various functions make easier user. Large parts MatchTime originally developed purpose analyzing data large German health-insurance provider. , functions designed fast RAM efficient, relying almost entirely data.table package internally. Input datasets ~ 20 million rows can used function regular computer without issues. Note package still early phases development. Large breaking changes may therefore occur without warnings.","code":""},{"path":"https://robindenz1.github.io/MatchTime/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Matching for Causal Inference with Time-Dependent Treatments","text":"developmental version may installed github using remotes R-Package:","code":"library(remotes)  remotes::install_github(\"RobinDenz1/MatchTime\")"},{"path":"https://robindenz1.github.io/MatchTime/index.html","id":"bug-reports-and-feature-requests","dir":"","previous_headings":"","what":"Bug Reports and Feature Requests","title":"Matching for Causal Inference with Time-Dependent Treatments","text":"encounter bugs specific feature requests, please file Issue.","code":""},{"path":"https://robindenz1.github.io/MatchTime/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Matching for Causal Inference with Time-Dependent Treatments","text":"small example time-dependent matching continuous start-stop data given , using heart dataset survival package: MatchIt, balance statistics (“baseline”) can calculated using: actual number cases matched controls time, well number potential controls points time can additionally visualized using:  particular example, around t = 45, potential controls anymore, replacement used cases controls.","code":"library(data.table) library(MatchTime) library(MatchIt) library(survival)  data(\"heart\")  set.seed(1234)  m_obj <- match_time(transplant ~ age + surgery, data=heart, id=\"id\",                     match_method=\"nearest\") summary(m_obj) #> Call: #> match_time(formula = transplant ~ age + surgery, data = heart,  #>     id = \"id\", match_method = \"nearest\") #>  #> Summary of Balance for Matched Data at Baseline: #>         Means Treated Means Control Std. Mean Diff. Var. Ratio  eCDF Mean #> event       0.4745763     0.4883721              NA         NA 0.01379582 #> age        -2.5997517    -2.6059883              NA         NA 0.04105950 #> year        3.5534519     3.3669198              NA         NA 0.03444160 #> surgery     0.1864407     0.1162791              NA         NA 0.07016161 #>           eCDF Max #> event   0.01379582 #> age     0.12105712 #> year    0.07416880 #> surgery 0.07016161 #>  #> Sample Sizes: #>           Controls Treated All #> Matched         51      51 102 #> Unmatched       17      18  35 #> Included       103      69 103 #> Supplied       103      69 103 #>  #> Points in Time: #> Matching was performed at 43 unique points in time between 1 and 310. plot(m_obj)"},{"path":"https://robindenz1.github.io/MatchTime/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Matching for Causal Inference with Time-Dependent Treatments","text":"Use citation(\"MatchTime\") get relevant citation information.","code":""},{"path":"https://robindenz1.github.io/MatchTime/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Matching for Causal Inference with Time-Dependent Treatments","text":"© 2024 Robin Denz contents repository distributed GNU General Public License. can find full text License github repository. Alternatively, see http://www.gnu.org/licenses/.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_next_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Add the next time of an event to a match_time object — add_next_time","title":"Add the next time of an event to a match_time object — add_next_time","text":"cases, relevant events occur time case included matching using match_time function. times may correspond censoring event, time death etc. function allows users add time directly matched data. Contrary add_outcome function, adds one column data actually contains time \"event\", time event measured study entry.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_next_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add the next time of an event to a match_time object — add_next_time","text":"","code":"add_next_time(x, data, id=x$id, time=x$time,               include_same_t=TRUE,               name=\".next_time\")"},{"path":"https://robindenz1.github.io/MatchTime/reference/add_next_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add the next time of an event to a match_time object — add_next_time","text":"x match_time object created using match_time function. data data.table like object including exactly two columns: id (unique case identifier), time (time event occurred). May also object can coerced data.table, data.frame tibble. time next event per case added matched data. Cases events can simply omitted data. multiple events per person exist, included long-format (multiple rows per id). time first event inclusion matching data added, previous events events afterwards ignored. id single character string specifying column data, specifying unique case identifier. default name used original match_time used . time single character string specifying column data, specifying column containing event times. default name used original match_time used . include_same_t Either TRUE FALSE, specifying whether time inclusion (.treat_time x$data) included adding next event time. TRUE (default), event happening exactly time inclusion considered next event. FALSE, event happening exactly time inclusion considered \"past event\" instead. latter case, events strictly inclusion time added matched data. name single character string specifying name column containing next event time added data object contained x. Defaults .next_time. name already present, error message returned instead.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_next_time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add the next time of an event to a match_time object — add_next_time","text":"first glance might confusing whether use add_next_time add_outcome, distinction actually quite simple. Use add_next_time whenever want add actual time occurence next event inclusion time use add_outcome whenever interested adding time next event measured inclusion time (possible subject censoring). name suggests, latter usually used time--event outcomes, former usually used add extra information required add sorts right-censoring etc.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_next_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add the next time of an event to a match_time object — add_next_time","text":"Returns modified match_time object. essentially object supplied x, also contains new column: name (time occurence next event).","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_next_time.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add the next time of an event to a match_time object — add_next_time","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/add_next_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add the next time of an event to a match_time object — add_next_time","text":"","code":"library(data.table) library(MatchTime)  # only execute if packages are available if (requireNamespace(\"survival\") & requireNamespace(\"MatchIt\")) {  library(survival) library(MatchIt)  # set random seed to make the output replicably set.seed(1234)  # load \"heart\" data from survival package data(\"heart\") heart <- heart[, c(\"id\", \"start\", \"stop\", \"transplant\", \"age\", \"surgery\")]  # suppose we had an extra dataset with events that looks like this # NOTE: these are not all events in the real \"heart\" data and is merely used #       for showcasing the functionality of add_next_time() d_events <- data.table(id=c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),                        time=c(50, 6, 16, 39, 18, 3, 675, 40, 85, 58))  # perform nearest neighbor time-dependent matching on \"age\" and \"surgery\" # (plus exact matching on time) m_obj <- match_time(transplant ~ age + surgery, data=heart, id=\"id\",                     match_method=\"nearest\")  # add the time of next event to match_time object m_obj <- add_next_time(m_obj, data=d_events, time=\"time\") head(m_obj$data) } #>  #> Attaching package: ‘MatchIt’ #> The following object is masked from ‘package:MatchTime’: #>  #>     match_data #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Key: <id> #>       id .id_new .id_pair .treat .treat_time .next_treat_time .fully_matched #>    <num>   <int>   <char> <lgcl>       <num>            <num>         <lgcl> #> 1:     1      72       36  FALSE          27               NA           TRUE #> 2:     3       1        1   TRUE           1               NA           TRUE #> 3:     4      10        5  FALSE           2               36           TRUE #> 4:     4      89       45   TRUE          36               NA           TRUE #> 5:     7      86       43  FALSE          32               51           TRUE #> 6:     7     105       54   TRUE          51               NA          FALSE #>    .weights        age surgery .next_time #>       <num>      <num>   <num>      <num> #> 1:        1 -17.155373       0         50 #> 2:        1   6.297057       0         16 #> 3:        1  -7.737166       0         39 #> 4:        1  -7.737166       0         39 #> 5:        1   2.869268       0        675 #> 6:        0   2.869268       0        675"},{"path":"https://robindenz1.github.io/MatchTime/reference/add_outcome.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a Time-to-Event Outcome to a match_time object — add_outcome","title":"Add a Time-to-Event Outcome to a match_time object — add_outcome","text":"performing time-dependent matching using match_time function, users usually want add one outcomes data. function may used efficiently, potentially using different censoring schemes. equivalent including outcome start-stop dataset supplied matching process specifying outcomes argument.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_outcome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a Time-to-Event Outcome to a match_time object — add_outcome","text":"","code":"add_outcome(x, data, censor_at_treat=TRUE,             censor_pairs=FALSE, units=\"auto\",             id=x$id, time=x$time,             event_time_name=\".event_time\",             status_name=\".status\")"},{"path":"https://robindenz1.github.io/MatchTime/reference/add_outcome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a Time-to-Event Outcome to a match_time object — add_outcome","text":"x match_time object created using match_time function. data data.table like object including exactly two columns: id (unique case identifier), time (time event occurred). May also object can coerced data.table, data.frame tibble. event times supplied using argument put relation time case included matching process, giving time event. Cases events can simply omitted data. multiple events per person exist, included long-format (multiple rows per id). time first event inclusion matching data used, previous events events afterwards used. censor_at_treat Either TRUE FALSE, indicating whether created event time censored time next treatment. applies cases included matching process controls later become cases . Defaults TRUE. censor_pairs Either TRUE FALSE. used censor_at_treat=TRUE. set TRUE, case matched control censored time control censored due next treatment occurring. ratio > 1, minimum time \"artificial censoring\" used censoring time cases .id_pair. may cases sufficient deal covariate dependent censoring induced using censor_at_treat=TRUE. units Corresponds argument name difftime function. argument used time column corresponds Date (similar) variable. used indicate time-scale created event time (seconds, days, years, ...). id single character string specifying column data, specifying unique case identifier. default name used original match_time used . time single character string specifying column data, specifying column containing event times. default name used original match_time used . event_time_name single character string specifying name event time column added data object contained x. Defaults .event_time. name already present, error message returned instead. status_name single character string specifying name status column added data object contained x. Defaults .status. name already present, error message returned instead.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_outcome.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a Time-to-Event Outcome to a match_time object — add_outcome","text":"Different censoring schemes can used different target estimands. intention--treat type analysis, users usually censoring cases following treatment times. per-protocol type analysis, setting censor_at_treat usually right decision. Whether use censor_pairs additional choice depends user wants handle dependent censoring introduced using censor_at_treat=TRUE.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_outcome.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a Time-to-Event Outcome to a match_time object — add_outcome","text":"Returns modified match_time object. essentially object supplied x, also contains two new columns: event_time_name (time event censoring) status_name (logical variable indicating whether event occurred case censored).","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_outcome.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add a Time-to-Event Outcome to a match_time object — add_outcome","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/add_outcome.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a Time-to-Event Outcome to a match_time object — add_outcome","text":"","code":"library(data.table) library(MatchTime)  # only execute if packages are available if (requireNamespace(\"survival\") & requireNamespace(\"MatchIt\")) {  library(survival) library(MatchIt)  # set random seed to make the output replicably set.seed(1234)  # load \"heart\" data from survival package data(\"heart\") heart <- heart[, c(\"id\", \"start\", \"stop\", \"transplant\", \"age\", \"surgery\")]  # suppose we had an extra dataset with events that looks like this # NOTE: these are not all events in the real \"heart\" data and is merely used #       for showcasing the functionality of add_outcome() d_events <- data.table(id=c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),                        time=c(50, 6, 16, 39, 18, 3, 675, 40, 85, 58))  # perform nearest neighbor time-dependent matching on \"age\" and \"surgery\" # (plus exact matching on time) m_obj <- match_time(transplant ~ age + surgery, data=heart, id=\"id\",                     match_method=\"nearest\")  # add the event times to match_time object m_obj <- add_outcome(m_obj, data=d_events, time=\"time\") head(m_obj$data) } #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Key: <id> #>       id .id_new .id_pair .treat .treat_time .next_treat_time .fully_matched #>    <num>   <int>   <char> <lgcl>       <num>            <num>         <lgcl> #> 1:     1      72       36  FALSE          27               NA           TRUE #> 2:     3       1        1   TRUE           1               NA           TRUE #> 3:     4      10        5  FALSE           2               36           TRUE #> 4:     4      89       45   TRUE          36               NA           TRUE #> 5:     7      86       43  FALSE          32               51           TRUE #> 6:     7     105       54   TRUE          51               NA          FALSE #>    .weights        age surgery .status .event_time #>       <num>      <num>   <num>  <lgcl>       <num> #> 1:        1 -17.155373       0    TRUE          23 #> 2:        1   6.297057       0    TRUE          15 #> 3:        1  -7.737166       0   FALSE          34 #> 4:        1  -7.737166       0    TRUE           3 #> 5:        1   2.869268       0   FALSE          19 #> 6:        0   2.869268       0    TRUE         624"},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event.html","id":null,"dir":"Reference","previous_headings":"","what":"Add an indicator whether an event was occuring at baseline to a match_time object — add_previous_event","title":"Add an indicator whether an event was occuring at baseline to a match_time object — add_previous_event","text":"cases, relevant events occur time case included matching using match_time function. might unrelated treatment time-dependent variable duration. indicator whether type \"event\" currently ongoing inclusion time might required confounder adjustment analysis. variables already included start-stop data supplied match_time, included matched data automatically, case function needed. Otherwise, function offers easy fast way add indicator matched data.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add an indicator whether an event was occuring at baseline to a match_time object — add_previous_event","text":"","code":"add_previous_event(x, data, id=x$id, time=x$time,                    duration, include_same_t=FALSE,                    units=\"auto\", name=\".prev_event\")"},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add an indicator whether an event was occuring at baseline to a match_time object — add_previous_event","text":"x match_time object created using match_time function. data data.table like object including exactly two columns: id (unique case identifier), time (time \"event\" occurred). May also object can coerced data.table, data.frame tibble. multiple events per person exist, included long-format (multiple rows per id). supplied events currently ongoing inclusion time, added indicator TRUE, otherwise FALSE. Whether event still ongoing defined duration argument. id single character string specifying column data, specifying unique case identifier. default name used original match_time used . time single character string specifying column data, specifying column containing event times. default name used original match_time used . duration single positive number scala value specifying duration events listed data. time Date object something similar, duration usually given days. Internally, whether event lies duration determined using + S3 method, defaults days Date objects. Users may use functions packages like lubridate use units specifying argument accordingly. units Corresponds argument name difftime function. argument used time column corresponds Date (similar) variable. used indicate time-scale duration (seconds, days, years, ...). name single character string specifying name column containing indicator added data object contained x. Defaults .prev_event. name already present, error message returned instead. include_same_t Either TRUE FALSE (default), specifying whether time inclusion (.treat_time x$data) included adding next indicator. TRUE, event starting ending exactly time inclusion considered previous event, resulting added indicator TRUE. FALSE, event starting ending exactly time inclusion considered previous event.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add an indicator whether an event was occuring at baseline to a match_time object — add_previous_event","text":"cases easier cleaner just add variables start-stop data supplied data argument match_time, regardless whether matching performed variables . way, present output data without function calls. cases, however, dataset may large allow variables present. might case variable changes many points time, requiring many rows per id. cases might necessary add later make matching process possible.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add an indicator whether an event was occuring at baseline to a match_time object — add_previous_event","text":"Returns modified match_time object. essentially object supplied x, also contains new column: name (indicator whether event currently ongoing inclusion time).","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add an indicator whether an event was occuring at baseline to a match_time object — add_previous_event","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add an indicator whether an event was occuring at baseline to a match_time object — add_previous_event","text":"","code":"library(data.table) library(MatchTime)  # only execute if packages are available if (requireNamespace(\"survival\") & requireNamespace(\"MatchIt\")) {  library(survival) library(MatchIt)  # set random seed to make the output replicably set.seed(1234)  # load \"heart\" data from survival package data(\"heart\") heart <- heart[, c(\"id\", \"start\", \"stop\", \"transplant\", \"age\", \"surgery\")]  # suppose we had an extra dataset with events that looks like this # NOTE: these are not actual events in the real \"heart\" data and is merely used #       for showcasing the functionality of add_previous_event() d_events <- data.table(id=c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),                        time=c(5, 2, 12, 39, 2, 665, 675, 4, 1, 23))  # perform nearest neighbor time-dependent matching on \"age\" and \"surgery\" # (plus exact matching on time) m_obj <- match_time(transplant ~ age + surgery, data=heart, id=\"id\",                     match_method=\"nearest\")  # add the previous event indicator to match_time object, # assuming they always have a duration of 20 m_obj <- add_previous_event(m_obj, data=d_events, time=\"time\", duration=20) head(m_obj$data) } #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Key: <id> #>       id .id_new .id_pair .treat .treat_time .next_treat_time .fully_matched #>    <num>   <int>   <char> <lgcl>       <num>            <num>         <lgcl> #> 1:     1      72       36  FALSE          27               NA           TRUE #> 2:     3       1        1   TRUE           1               NA           TRUE #> 3:     4      10        5  FALSE           2               36           TRUE #> 4:     4      89       45   TRUE          36               NA           TRUE #> 5:     7      86       43  FALSE          32               51           TRUE #> 6:     7     105       54   TRUE          51               NA          FALSE #>    .weights        age surgery .prev_event #>       <num>      <num>   <num>      <lgcl> #> 1:        1 -17.155373       0       FALSE #> 2:        1   6.297057       0       FALSE #> 3:        1  -7.737166       0       FALSE #> 4:        1  -7.737166       0       FALSE #> 5:        1   2.869268       0       FALSE #> 6:        0   2.869268       0       FALSE"},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a count of the number of events occured before inclusion to a match_time object — add_previous_event_count","title":"Add a count of the number of events occured before inclusion to a match_time object — add_previous_event_count","text":"cases, relevant events occur time case included matching using match_time function. might unrelated treatment time-dependent variable duration. count many \"events\" occured set duration inclusion time might required confounder adjustment analysis. variables already included start-stop data supplied match_time, included matched data automatically, case function needed. Otherwise, function offers easy fast way add count matched data.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a count of the number of events occured before inclusion to a match_time object — add_previous_event_count","text":"","code":"add_previous_event_count(x, data, id=x$id, time=x$time,                          duration, include_same_t=FALSE,                          units=\"auto\", name=\".prev_event_count\")"},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a count of the number of events occured before inclusion to a match_time object — add_previous_event_count","text":"x match_time object created using match_time function. data data.table like object including exactly two columns: id (unique case identifier), time (time \"event\" occurred). May also object can coerced data.table, data.frame tibble. multiple events per person exist, included long-format (multiple rows per id). id single character string specifying column data, specifying unique case identifier. default name used original match_time used . time single character string specifying column data, specifying column containing event times. default name used original match_time used . duration single positive number specifying duration inclusion time (.treat_time x$data) events counted. example, setting duration = 20 means number events occuring 20 time units inclusion time counted. include_same_t Either TRUE FALSE (default), specifying whether time inclusion (.treat_time x$data) included adding next indicator. TRUE, event occuring exactly time inclusion considered previous event, resulting added indicator one point higher. FALSE, event occuring exactly time inclusion considered previous event. units Corresponds argument name difftime function. argument used time column corresponds Date (similar) variable. used indicate time-scale duration (seconds, days, years, ...). name single character string specifying name column containing count added data object contained x. Defaults .prev_event_count. name already present, error message returned instead.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event_count.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a count of the number of events occured before inclusion to a match_time object — add_previous_event_count","text":"cases easier cleaner just add variables start-stop data supplied data argument match_time, regardless whether matching performed variables . way, present output data without function calls. cases, however, dataset may large allow variables present. might case variable changes many points time, requiring many rows per id. cases might necessary add later make matching process possible.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a count of the number of events occured before inclusion to a match_time object — add_previous_event_count","text":"Returns modified match_time object. essentially object supplied x, also contains new column: name (count events occured duration time units inclusion time).","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event_count.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add a count of the number of events occured before inclusion to a match_time object — add_previous_event_count","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/add_previous_event_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a count of the number of events occured before inclusion to a match_time object — add_previous_event_count","text":"","code":"library(data.table) library(MatchTime)  # only execute if packages are available if (requireNamespace(\"survival\") & requireNamespace(\"MatchIt\")) {  library(survival) library(MatchIt)  # set random seed to make the output replicably set.seed(1234)  # load \"heart\" data from survival package data(\"heart\") heart <- heart[, c(\"id\", \"start\", \"stop\", \"transplant\", \"age\", \"surgery\")]  # suppose we had an extra dataset with events that looks like this # NOTE: these are not actual events in the real \"heart\" data and is merely used #       for showcasing the functionality of add_previous_event() d_events <- data.table(id=c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),                        time=c(5, 2, 12, 39, 2, 665, 675, 4, 1, 23))  # perform nearest neighbor time-dependent matching on \"age\" and \"surgery\" # (plus exact matching on time) m_obj <- match_time(transplant ~ age + surgery, data=heart, id=\"id\",                     match_method=\"nearest\")  # add the count of events occuring 20 time units before inclusion # to the match_time object m_obj <- add_previous_event_count(m_obj, data=d_events, time=\"time\",                                   duration=20) head(m_obj$data) } #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Key: <id> #>       id .id_new .id_pair .treat .treat_time .next_treat_time .fully_matched #>    <num>   <int>   <char> <lgcl>       <num>            <num>         <lgcl> #> 1:     1      72       36  FALSE          27               NA           TRUE #> 2:     3       1        1   TRUE           1               NA           TRUE #> 3:     4      10        5  FALSE           2               36           TRUE #> 4:     4      89       45   TRUE          36               NA           TRUE #> 5:     7      86       43  FALSE          32               51           TRUE #> 6:     7     105       54   TRUE          51               NA          FALSE #>    .weights        age surgery .prev_event_count #>       <num>      <num>   <num>             <int> #> 1:        1 -17.155373       0                 0 #> 2:        1   6.297057       0                 0 #> 3:        1  -7.737166       0                 0 #> 4:        1  -7.737166       0                 0 #> 5:        1   2.869268       0                 0 #> 6:        0   2.869268       0                 0"},{"path":"https://robindenz1.github.io/MatchTime/reference/bal.tab.match_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Display Balance Statistics in a Table for match_time objects — bal.tab.match_time","title":"Display Balance Statistics in a Table for match_time objects — bal.tab.match_time","text":"function extends bal.tab function cobalt package allow input match_time object. allows users directly call bal.tab function output match_time function, mimicking usage function using matchit function MatchIt package. existence function also allows users directly call love.plot function match_time objects.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/bal.tab.match_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display Balance Statistics in a Table for match_time objects — bal.tab.match_time","text":"","code":"# S3 method for class 'match_time' bal.tab(x, s.d.denom, remove_unmatched=TRUE,         n_required=x$info$ratio, ...)"},{"path":"https://robindenz1.github.io/MatchTime/reference/bal.tab.match_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display Balance Statistics in a Table for match_time objects — bal.tab.match_time","text":"x match_time object created using match_time function. s.d.denom Argument name bal.tab. remove_unmatched Whether remove unmatched individuals calculating balance statistics. Internally, match_data function called , please see documentation function information. influence computed sample sizes. n_required argument name match_data. ... arguments passed bal.tab.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/bal.tab.match_time.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Display Balance Statistics in a Table for match_time objects — bal.tab.match_time","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/bal.tab.match_time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Display Balance Statistics in a Table for match_time objects — bal.tab.match_time","text":"balance statistics calculated using method always considered \"unadjusted\". reason possible make distinction \"unadjusted\" \"adjusted\" balance statistics directly using time-dependent matching, balance assessed \"baseline\" (e.g. time individuals first included matching process). easy matched data. just use covariate value time entry (.treat_time), whole point matching process. Since baseline period unmatched data, however, balance statistics calculated. conceivable strategy get \"unadjusted\" \"adjusted\" estimates match time (using match_method=\"none\" match_time) calculate balance statistics immediatly afterwards. one adjust unbalanced covariates using regular method weighting, assessing balance statistics afterwards. matching covariates included match_time, longer works. calling love.plot, estimates thus also always displayed \"unadjusted\". Users can change entirely remove labelling options love.plot function.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/bal.tab.match_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display Balance Statistics in a Table for match_time objects — bal.tab.match_time","text":"Returns bal.tab object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/bal.tab.match_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display Balance Statistics in a Table for match_time objects — bal.tab.match_time","text":"","code":"library(data.table) library(MatchTime)  # only execute if packages are available if (requireNamespace(\"cobalt\") & requireNamespace(\"survival\") &     requireNamespace(\"MatchIt\")) {  library(cobalt) library(survival) library(MatchIt)  # set random seed to make the output replicably set.seed(1234)  # load \"heart\" data from survival package data(\"heart\")  # perform nearest neighbor time-dependent matching on \"age\" and \"surgery\" # (plus exact matching on time) out <- match_time(transplant ~ age + surgery, data=heart, id=\"id\",                   match_method=\"nearest\") bal.tab(out) } #>  cobalt (Version 4.6.0, Build Date: 2025-04-15) #>  #> Attaching package: ‘cobalt’ #> The following object is masked from ‘package:MatchIt’: #>  #>     lalonde #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Balance Measures #>            Type Diff.Un #> event    Binary  0.4118 #> age     Contin.  0.1677 #> year    Contin.  0.0048 #> surgery  Binary  0.0000 #>  #> Sample sizes #>     FALSE TRUE #> All    51   51"},{"path":"https://robindenz1.github.io/MatchTime/reference/fast_exact_matching.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast Exact Matching with a Binary Treatment — fast_exact_matching","title":"Fast Exact Matching with a Binary Treatment — fast_exact_matching","text":"function matches one multiple controls cases exactly values one multiple categorical variables. Technically works continuous variables well, probably work well practice due low probability exact matches.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/fast_exact_matching.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast Exact Matching with a Binary Treatment — fast_exact_matching","text":"","code":"fast_exact_matching(formula, data, replace=FALSE,                     ratio=1, estimand=\"ATT\",                     remove_unmatched=TRUE, n_required=ratio,                     if_no_match=\"warn\")"},{"path":"https://robindenz1.github.io/MatchTime/reference/fast_exact_matching.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast Exact Matching with a Binary Treatment — fast_exact_matching","text":"formula formula object binary treatment variable left-hand side variables matched right hand side. binary treatment ideally coded logical variable (TRUE = treated, FALSE = untreated). case, function internally coerces variable logical using rules described details. data data.table like object containing columns mentioned formula. Additional columns allowed included output, although matched mentioned right hand side formula. replace Whether sample controls without replacement. usual matching, using ratio > 1 control can occur per case. Note using replacement makes function significantly slower, computational overhead ensuring control used oncer per case. ratio many control units matched treated unit k:1 matching. single integer value. default 1 1:1 matching. estimand estimand target. Can either \"ATT\" (default) get dataset estimate average treatment effect treated, \"ATC\" target average treatment effect untreated. using \"ATC\", treatment labels simply swapped internally matching swapped back afterwards. remove_unmatched Either TRUE (default) FALSE, specifying whether remove pairs enough matches. number matches case received matching can set using n_required argument. n_required single positive integer, specifying number matched controls pair needs stay data. example, 1:1 matching used user wants keep pairs cases actually receive one control, set 1. ratio=3 used users want keep pairs 2 matched controls, set 2 etc. default, number matches specified ratio argument original match_time call used. if_no_match Must either \"stop\", \"warn\" (default) \"nothing\". Controls whether throw error, warning silently accept enough controls matched one cases.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/fast_exact_matching.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fast Exact Matching with a Binary Treatment — fast_exact_matching","text":"function first extracts cases data, defined rows data binary variable (left-hand side formula) TRUE. stratified random sample drawn remaining dataset consisting controls, strata variables matched . drawing ratio controls case exactly values strata respective case, perfectly exact ratio:1 matching performed. basic form matching without lot flexibility. also supports binary treatments. almost every case much better just use matchit function excellent MatchIt package instead. reason use fast_exact_matching function better performance large datasets. controls matched directly cases default, resulting dataset may generally used get estimates average treatment effect treated (ATT). setting estimand=\"ATC\", matching process reversed. Instead matching controls cases, cases matched controls resulting dataset may used estimate average treatment effect untreated (ATC). estimands currently supported. .weights column output calculated using method used matchit. Identifying \"treated\" group: Ideally, treatment specified LHS formula argument coded logical variable, TRUE corresponds \"treated\" group FALSE corresponds \"control\" group. case, function coerce type internally using following rules: 1.) variable consists numbers 0 1 (coded numeric), 0 considered \"control\" group 1 \"treated\" group; 2.) otherwise, variable factor, levels(treat)[1] considered \"control\" group value \"treated\" group; 3.) otherwise sort(unique(treat))[1] considered \"control\" value treated. safest ensure treatment variable logical variable. either case, output contain treatment logical variable. Using replace=TRUE: replace=TRUE used, output may contain multiple rows supplied rows. Namely, include one row every time control choosen control. example, id = 3 used control id = 5, 6, 7, 8, occur dataset 4 times, time different .id_pair. user wants differentiate cases, needs done add unique id column (name) data matching process. variable data, variable preserved matching.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/fast_exact_matching.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast Exact Matching with a Binary Treatment — fast_exact_matching","text":"Returns single data.table containing columns data plus two additional columns called \".id_pair\", identifies rows belong one matched control / case pair .weights (numeric column including matching weights).","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/fast_exact_matching.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fast Exact Matching with a Binary Treatment — fast_exact_matching","text":"Elizabeth . Stuart (2010). \"Matching Methods Causal Inference: Review Look Forward\". : Statistical Science 25.1, pp. 1-21.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/fast_exact_matching.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fast Exact Matching with a Binary Treatment — fast_exact_matching","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/fast_exact_matching.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast Exact Matching with a Binary Treatment — fast_exact_matching","text":"","code":"library(MatchTime) library(data.table)  set.seed(12341)  ## generate some random example data n <- 1000 data <- data.table(sex=sample(c(\"m\", \"f\"), size=n, replace=TRUE),                    age_cat=sample(c(\"10\", \"20\", \"30\"), size=n, replace=TRUE),                    treatment=sample(c(TRUE, FALSE), size=n, prob=c(0.1, 0.9),                                     replace=TRUE))  # perform 1:1 exact matching on sex, without replacement out <- fast_exact_matching(treatment ~ sex,                            data=data,                            ratio=1)  # perform 3:1 exact matching on sex, without replacement out <- fast_exact_matching(treatment ~ sex,                            data=data,                            ratio=3,                            replace=TRUE)  # perform 1:1 exact matching on sex, with replacement using the ATC out <- fast_exact_matching(treatment ~ sex,                            data=data,                            ratio=1,                            estimand=\"ATC\",                            replace=TRUE)  # perform 1:1 exact matching on sex and age_cat, without replacement out <- fast_exact_matching(treatment ~ sex + age_cat,                            data=data,                            ratio=1)"},{"path":"https://robindenz1.github.io/MatchTime/reference/fill_gaps_start_stop.html","id":null,"dir":"Reference","previous_headings":"","what":"Add missing intervals to incomplete start-stop data — fill_gaps_start_stop","title":"Add missing intervals to incomplete start-stop data — fill_gaps_start_stop","text":"start-stop datasets may missing intervals cases. function adds intervals data, might needed processing.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/fill_gaps_start_stop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add missing intervals to incomplete start-stop data — fill_gaps_start_stop","text":"","code":"fill_gaps_start_stop(data, id, start=\"start\", stop=\"stop\",                      first_time=NULL, last_time=NULL,                      missing_indicator=TRUE, ...)"},{"path":"https://robindenz1.github.io/MatchTime/reference/fill_gaps_start_stop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add missing intervals to incomplete start-stop data — fill_gaps_start_stop","text":"data data.table like object including least three columns: id (unique case identifier), start (beginning time-interval) stop (end time-interval). May also object can coerced data.table, data.frame tibble. Intervals coded (start, stop]. id single character string specifying column id specifying unique case identifier. start single character string specifying column data specifying beginning time-interval. Defaults \"start\". stop single character string specifying column data specifying ending time-interval. Defaults \"stop\". first_time Corresponds argument name merge_start_stop function. last_time Corresponds argument name merge_start_stop function. missing_indicator Either TRUE (default) FALSE, specifying whether logical column added data includes indicator whether corresponding interval present original data . TRUE, column added using name \".in_data\". column TRUE interval present FALSE . ... arguments passed merge_start_stop function.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/fill_gaps_start_stop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add missing intervals to incomplete start-stop data — fill_gaps_start_stop","text":"input data missing intervals, input stays unchanged. missing intervals added, value NA columns start, stop id. Internally, function simply calls merge_start_stop function appropriate input argument (merging input data essentially empty second dataset using =TRUE). , arguments merge_start_stop function, setting default values using defaults argument may also used .","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/fill_gaps_start_stop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add missing intervals to incomplete start-stop data — fill_gaps_start_stop","text":"Returns single data.table containing start-stop data missing intervals added.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/fill_gaps_start_stop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add missing intervals to incomplete start-stop data — fill_gaps_start_stop","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/fill_gaps_start_stop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add missing intervals to incomplete start-stop data — fill_gaps_start_stop","text":"","code":"library(MatchTime) library(data.table)  ## define some example data # this dataset is missing two intervals: (24, 28] for id = 1 and # (245, 343] for id = 2 data <- data.table(id=c(1, 1, 1, 2, 2, 3),                    start=c(0, 28, 66, 25, 343, 10),                    stop=c(24, 66, 143, 245, 1233, 3214),                    A=c(10, 122, 3434, 223, 233, 0.46))  # add those intervals back out <- fill_gaps_start_stop(data, id=\"id\") print(out) #> Key: <id, start> #>       id start  stop .in_data       A #>    <num> <num> <num>   <lgcl>   <num> #> 1:     1     0    24     TRUE   10.00 #> 2:     1    24    28    FALSE      NA #> 3:     1    28    66     TRUE  122.00 #> 4:     1    66   143     TRUE 3434.00 #> 5:     2    25   245     TRUE  223.00 #> 6:     2   245   343    FALSE      NA #> 7:     2   343  1233     TRUE  233.00 #> 8:     3    10  3214     TRUE    0.46  # add the missing intervals, but also add missing intervals from 0 to first # observed value per id out <- fill_gaps_start_stop(data, id=\"id\", first_time=0) print(out) #> Key: <id, start> #>        id start  stop .in_data       A #>     <num> <num> <num>   <lgcl>   <num> #>  1:     1     0    24     TRUE   10.00 #>  2:     1    24    28    FALSE      NA #>  3:     1    28    66     TRUE  122.00 #>  4:     1    66   143     TRUE 3434.00 #>  5:     2     0    25    FALSE      NA #>  6:     2    25   245     TRUE  223.00 #>  7:     2   245   343    FALSE      NA #>  8:     2   343  1233     TRUE  233.00 #>  9:     3     0    10    FALSE      NA #> 10:     3    10  3214     TRUE    0.46"},{"path":"https://robindenz1.github.io/MatchTime/reference/long2start_stop.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a long-format dataset into the start-stop format — long2start_stop","title":"Transform a long-format dataset into the start-stop format — long2start_stop","text":"function transforms data.table like object long-format (one row per person per time point) data.table start-stop format (one row per person-specific period variables changed).","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/long2start_stop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a long-format dataset into the start-stop format — long2start_stop","text":"","code":"long2start_stop(data, id, time, varying, start_name=\"start\",                 stop_name=\"stop\")"},{"path":"https://robindenz1.github.io/MatchTime/reference/long2start_stop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a long-format dataset into the start-stop format — long2start_stop","text":"data data.table object can coerced data.table (data.frame) including data long-format. supplied data include full information individuals, e.g. points time first time last time per individual missing. id single character string specifying unique person identifier included data. time single character string specifying time variable included data coded integers. varying character vector specifying names variables included data may change time. start_name single character string, specifying name \"start\" variable resulting data. Defaults \"start\". stop_name start_name \"stop\" column.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/long2start_stop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform a long-format dataset into the start-stop format — long2start_stop","text":"created start-stop columns coded [start, stop), meaning overlapping. non-overlapping intervals desired, users can simply substract 1 stop column. function relies data.table syntax make data transformation RAM efficient fast possible.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/long2start_stop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a long-format dataset into the start-stop format — long2start_stop","text":"Returns data.table containing columns id (unique person identifier), start_name (integer variable encoding beginning intervals), stop (integer variable encoding end intervals) variables included input data start-stop format.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/long2start_stop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform a long-format dataset into the start-stop format — long2start_stop","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/long2start_stop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a long-format dataset into the start-stop format — long2start_stop","text":"","code":"library(MatchTime) library(data.table)  # generate example data in long format long <- data.table(.id=rep(seq_len(10), each=5),                    .time=rep(seq_len(5), 10),                    A=c(rep(FALSE, 43), TRUE, TRUE, rep(FALSE, 3), TRUE,                            TRUE),                    B=FALSE) setkey(long, .id, .time)  # transform to start-stop format long2start_stop(data=long, id=\".id\", time=\".time\", varying=c(\"A\", \"B\")) #>       .id start  stop      A      B #>     <int> <int> <int> <lgcl> <lgcl> #>  1:     1     1     6  FALSE  FALSE #>  2:     2     1     6  FALSE  FALSE #>  3:     3     1     6  FALSE  FALSE #>  4:     4     1     6  FALSE  FALSE #>  5:     5     1     6  FALSE  FALSE #>  6:     6     1     6  FALSE  FALSE #>  7:     7     1     6  FALSE  FALSE #>  8:     8     1     6  FALSE  FALSE #>  9:     9     1     4  FALSE  FALSE #> 10:     9     4     6   TRUE  FALSE #> 11:    10     1     4  FALSE  FALSE #> 12:    10     4     6   TRUE  FALSE"},{"path":"https://robindenz1.github.io/MatchTime/reference/match_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a matched dataset from a match_time object — match_data","title":"Construct a matched dataset from a match_time object — match_data","text":"performing time-dependent matching using match_time function, users usually want extract resulting data. resulting data contain cases receive specified number matches, function can called remove data extraction.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/match_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a matched dataset from a match_time object — match_data","text":"","code":"match_data(object, remove_unmatched=TRUE, n_required=object$info$ratio)"},{"path":"https://robindenz1.github.io/MatchTime/reference/match_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a matched dataset from a match_time object — match_data","text":"object match_time object created using match_time function. remove_unmatched Either TRUE (default) FALSE, specifying whether remove pairs enough matches. number matches case received matching can set using n_required argument. n_required single positive integer, specifying number matched controls pair needs stay data. example, 1:1 matching used user wants keep pairs cases actually receive one control, set 1. ratio=3 used users want keep pairs 2 matched controls, set 2 etc. default, number matches specified ratio argument original match_time call used. warning produced users try use method match_method original match_time call set method matchit use pair matching.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/match_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a matched dataset from a match_time object — match_data","text":"Returns single data.table. data.table include columns $data object output match_time, exception \".fully_matched\" column. Note \".id_pair\" variable created match_time, also present output .","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/match_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a matched dataset from a match_time object — match_data","text":"resulting data may contain multiple rows per actual individual, depending arguments used original match_time call. might individuals included controls cases different points time, included controls multiple points time (replace_over_t=TRUE), included controls multiple times point time (replace_at_t=TRUE), due mix reasons. Contrary MatchIt package, option change . \"Replaced\" individuals always appear often selected matching process. output therefore also always contain \".id_pair\" column, indicating \"pair\" cases controls . instance column included match_method set method matchit create pairs internally.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/match_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Construct a matched dataset from a match_time object — match_data","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/match_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a matched dataset from a match_time object — match_data","text":"","code":"library(data.table) library(MatchTime)  # only execute if packages are available if (requireNamespace(\"survival\") & requireNamespace(\"MatchIt\")) {  library(survival) library(MatchIt)  # set random seed to make the output replicably set.seed(1234)  # load \"heart\" data from survival package data(\"heart\")  # perform nearest neighbor time-dependent matching on \"age\" and \"surgery\" # (plus exact matching on time) m_obj <- match_time(transplant ~ age + surgery, data=heart, id=\"id\",                     match_method=\"nearest\")  # get data without unmatched individuals data <- MatchTime::match_data(m_obj) head(data) } #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Key: <id> #>       id .id_new .id_pair .treat .treat_time .next_treat_time .weights event #>    <num>   <int>   <char> <lgcl>       <num>            <num>    <num> <num> #> 1:     1      72       36  FALSE          27               NA        1     1 #> 2:     3       1        1   TRUE           1               NA        1     1 #> 3:     4      10        5  FALSE           2               36        1     0 #> 4:     4      89       45   TRUE          36               NA        1     1 #> 5:     7      86       43  FALSE          32               51        1     0 #> 6:     8      16        8  FALSE           3               NA        1     1 #>           age      year surgery #>         <num>     <num>   <num> #> 1: -17.155373 0.1232033       0 #> 2:   6.297057 0.2655715       0 #> 3:  -7.737166 0.4900753       0 #> 4:  -7.737166 0.4900753       0 #> 5:   2.869268 0.7802875       0 #> 6:  -2.650240 0.8350445       0"},{"path":"https://robindenz1.github.io/MatchTime/reference/match_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Matching for Causal Inference with Time-Dependent Treatments — match_time","title":"Matching for Causal Inference with Time-Dependent Treatments — match_time","text":"function implements multiple methods match untreated controls treated individuals time-dependent fashion described Thomas et al. (2020). approach also known sequential trial emulation. contrast implementations, function supports continuous datetime input allows matching directly time-fixed time-dependent covariates time. internally uses data.table package keep function fast allows users use matchit function excellent MatchIt package perform actual matching point time flexibility. Similar matchit, page documents overall use match_time(). Specifics match_time() works individual methods individual pages linked Detail section consulted.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/match_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matching for Causal Inference with Time-Dependent Treatments — match_time","text":"","code":"match_time(formula, data, id, inclusion=NA,            outcomes=NA, start=\"start\", stop=\"stop\",            method=c(\"brsm\", \"psm\", \"pgm\",                     \"dsm\", \"greedy\"),            replace_over_t=FALSE, replace_at_t=FALSE,            replace_cases=TRUE, estimand=\"ATT\", ratio=1,            recruitment_start=NULL, recruitment_stop=NULL,            match_method=\"fast_exact\",            matchit_args=list(), save_matchit=FALSE,            censor_at_treat=TRUE, censor_pairs=FALSE,            units=\"auto\", verbose=FALSE, ...)"},{"path":"https://robindenz1.github.io/MatchTime/reference/match_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matching for Causal Inference with Time-Dependent Treatments — match_time","text":"formula formula object binary treatment variable left hand side covariates balanced right hand side. Interactions functions covariates currently allowed. treatment variable ideally coded logical variable (TRUE = treatment, FALSE = control). See details \"treated\" group identified input types. data data.table like object start-stop format, containing information variables time-invariant time-dependent potentially outcomes. row corresponds period time variables changed. intervals defined start stop columns. start column gives time period started, stop column denotes time period ended. Intervals coded right-open (corresponds [start, stop)). Continuous (float) discrete (integer, datetime) values supported time columns. dataset also include id variable (see argument id). See details examples information, including events coded. id single character string specifying unique case identifier data. inclusion optional character vector specifying logical variables data used inclusion criteria. TRUE period specified start stop columns data corresponds period individual fufills inclusion criteria FALSE individual . periods named variables FALSE excluded matching process dynamically. supplying criteria separate columns, reasons exclusions automatically included output. Set NA use functionality (default). outcomes optional character vector specify logical variables data treated (potentially right-censored) outcomes. coded differently time-dependent variables explained throughout documentation relevant vignette. Columns named argument re-coded output appear time first occurrence respective outcome inclusion matching process. equivalent calling add_outcome function output object value outcomes. Note outcomes matched , occur respective point time. Set NA use functionality (default). start single character string specifying column data specifying beginning time-interval. Defaults \"start\". stop single character string specifying column data specifying end time-interval. Defaults \"stop\". method single character string, specifying method used select controls. Currently supports \"brsm\" balanced risk set matching, \"psm\" time-dependent propensity score matching, \"pgm\" time-dependent prognostic score matching, \"dsm\" double score matching \"greedy\" simply available controls taken step. Depending method, arguments may allowed required. explained method-specific documentation page. See details information. replace_over_t Whether allow usage individuals controls multiple points time. TRUE, person may used control every point time switches control case. using method=\"greedy\", argument always treated TRUE. replace_at_t Whether allow usage individuals controls point time. match_method set valid method matchit argument passed replace argument matchit function. replace_cases Whether include individuals already used controls cases also get treatment later. purely experimental usually stay default value TRUE regardless method arguments, unless good reasons change . estimand Currently allows \"ATT\" get dataset estimate average treatment effect treated (controls choosen similar treated individuals). values currently supported. Note argument passed matchit match_method set valid method matchit. simply make sense use anything \"ATT\" . ratio many control units matched treated unit k:1 matching. single integer value. default 1 1:1 matching. match_method set valid method matchit, argument passed argument name matchit function. recruitment_start optional single value specifying time matching process start. first time individuals receiving treatment included matching process. Note individuals receiving treatment time period considered treated, regardless whether receive treatment date . users want exclude previously treated individuals, inclusion argument used input data modified accordingly. Set NULL use available information data (default). recruitment_stop optional single value specifying time matching process stop. last time people still included matching process. Set NULL use available information data (default). match_method single character string specifying method used perform matching point time. Allowed values \"none\" (perform matching covariates), \"fast_exact\" (default, use fast exact matching implemented fast_exact_matching function package) valid method matchit function. latter used, argument passed method argument matchit function directly. arguments may passed matchit case using matchit_args argument. matchit_args named list arguments passed matchit match_method set valid method matchit. save_matchit Whether save objects created matchit call different points time using match_method used matchit. set TRUE, matchit_objects list include one entry per point time matching performed. Defaults FALSE save RAM space. censor_at_treat used outcomes specified. Either TRUE FALSE, indicating whether created event time censored time next treatment. applies cases included matching process controls later become cases . Defaults TRUE. censor_pairs used outcomes specified. Either TRUE FALSE. used censor_at_treat=TRUE. set TRUE, case matched control censored time control censored due next treatment occurring. ratio > 1, minimum time \"artificial censoring\" used censoring time cases .id_pair. may cases sufficient deal covariate dependent censoring induced using censor_at_treat=TRUE. units used outcomes specified. Corresponds argument name difftime function. argument used start stop columns correspond Date (similar) variable. used indicate time-scale created event time (seconds, days, years, ...). verbose Whether print summary many matches made point time (default). argument passed matchit function used. ... method specific arguments may specified. information method specific arguments allowed per method, please consult documentation page respective method. can accessed using, example, ?method_brsm ?method_psm.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/match_time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matching for Causal Inference with Time-Dependent Treatments — match_time","text":"works: function offers general implementation multiple methods time-dependent matching, also known  sequential trial emulation. works first identifying times point treatment status individual switches \"control\" \"treated\" sorting first last. matching performed subsequently distinct points time. individuals whose treatment status changed \"control\" \"treated\" \\(t\\) included matched data \"cases\". included individual, ratio controls choosen individuals yet receive treatment \\(t\\) also included matched data. controls can choosen based direct matching covariates (method=\"brsm\" - balanced risk set matching) matching scores estimated using Cox regression model (method=\"psm\", method=\"pgm\" method=\"dsm\") simply taking (method=\"greedy\"). time inclusion considered \"time-zero\" individuals included way. Individuals included controls point usually still included cases switch \"treated\", unless replace_cases=FALSE. Controls may picked controls multiple times \\(t\\) (argument replace_at_t) / multiple points time (argument replace_over_t). argument match_method controls exactly controls choosen. possible just pick random (match_method=\"none\") pick classical matching methods (setting match_method \"fast_exact\", \"nearest\", etc.). result dataset can analyzed using standard time--event methods, without need use special methods, marginal structural models, adjust treatment-confounder feedback forms time-dependent confounding. details examples given cited literature vignettes package. Implemented methods: Currently, function supports following methods: \"brsm\": balanced risk set matching \"psm\": time-dependent propensity score matching \"pgm\": time-dependent prognostic score matching \"dsm\": time-dependent double score matching \"greedy\": time-dependent greedy selection controls methods implemented sequential way differ much . main difference selection controls point time done differently. using method=\"brsm\" controls can picked based direct matching covariates (controlled using match_method argument). contrast, using score based methods, matching done exclusively estimated time-dependent score (propensity / prognostic score). using method=\"greedy\", possible controls taken point time. Identifying \"treated\" group: Ideally, treatment specified LHS formula argument coded logical variable, TRUE corresponds \"treated\" group FALSE corresponds \"control\" group. case, function coerce type internally using following rules: 1.) variable consists numbers 0 1 (coded numeric), 0 considered \"control\" group 1 \"treated\" group; 2.) otherwise, variable factor, levels(treat)[1] considered \"control\" group value \"treated\" group; 3.) otherwise sort(unique(treat))[1] considered \"control\" value treated. safest ensure treatment variable logical variable. either case, output contain treatment logical variable. Interval Coding: intervals supplied data argument required right-open intervals [start, stop), usual data format expected time--event modelling corresponds interval format tmerge function survival package. consequence, intervals length 0 (start==stop) supported result error message. Note events coded differently, described merge_start_stop function. least one outcome needs included using method=\"pgm\" method=\"dsm\", users may include arbitrary amount additional outcome event variables using outcomes argument. Adding Variables Users usually want add outcomes / baseline covariates data matching. can done using add_outcome add_covariate functions described detail respective documentation vignette. Assessing Covariate Balance balance covariates baseline can assessed using associated summary.match_time bal.tab.match_time functions. Note time-dependent matching possible assess balance baseline, treatment also time-dependent. recommended assess covariate balance whenever method used supposed create balance. using method=\"greedy\" method=\"brsm\" match_method=\"none\", however, needed. Performance Considerations function designed work large datasets (~ 20 million rows) large amounts points time (> 1000) regular computers. achieves use incredible data.table package. work large datasets, become slow due inherent computational complexity method. large data, using complicated matching methods match_method=\"genetic\" feasible. However, matching time match_method=\"none\" matching categorical variables using match_method=\"fast_exact\" still work.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/match_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matching for Causal Inference with Time-Dependent Treatments — match_time","text":"Returns match_time object containing following objects: data data.table containing matched data. Note dataset also contains unmatched cases. obtain dataset without unmatched individuals, please use match_data function. dataset contains least following columns: id: original id used supplied data, .id_new: new case-specific id ids occur multiple times treated distinct values, .id_pair: id distinguish matched pairs, applicable. column created match_method set method matchit allow usage get_matches, .treat: supplied treatment variable, .treat_time: time id included matching process, .next_treat_time: controls later receive treatment, time received treatment, .fully_matched: logical variable TRUE corresponding .id_pair consists one case ratio matched controls FALSE otherwise, .weights: column containing matching weights, generated separately point time. .ps_score: included method=\"psm\" method=\"dsm\" remove_ps=FALSE. Contains estimates \"propensity score\" .treat_time. .prog_score: included method=\"pgm\" method=\"dsm\" remove_prog=FALSE. Contains estimates \"prognostic score\" .treat_time. Potentially contains number additional covariates supplied original data, plus potential variables added using add_outcome, add_next_time similar functions. d_longest data.table containing last time observation id supplied data. trace data.table containing four columns: time (time matching occurred), new_cases (number new cases point time), matched_controls (number controls matched new cases time) potential_controls (number potential controls time). id value supplied id argument. time character string used internally identify time datasets. info list containing various information matching process. sizes list containing various information overall sample sizes stage. exclusion list containing two data.tables contain ids removed data different stages due inclusion well reason removal. matchit_objects list matchit objects created point time matching performed. included match_method set valid method matchit save_matchit=TRUE. ps_model coxph model fit estimate time-dependent propensity score. included method=\"psm\" method=\"dsm\". prog_model coxph model fit estimate time-dependent prognostic score. included method=\"pgm\" method=\"dsm\". call original function call.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/match_time.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Matching for Causal Inference with Time-Dependent Treatments — match_time","text":"Thomas, Laine E., Siyun Yang, Daniel Wojdyla, Douglas E. Schaubel (2020). \"Matching Time-Dependent Treatments: Review Look Forward\". : Statistics Medicine 39, pp. 2350-2370. Li, Yunfei Pail, Kathleen J. Propert, Paul R. Rosenbaum (2001). \"Balanced Risk Set Matching\". : Journal American Statistical Association 96.455, pp. 870-882. Lu, Bo (2005). \"Propensity Score Matching Time-Dependent Covariates\". : Biometrics 61.3, pp. 721-728.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/match_time.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Matching for Causal Inference with Time-Dependent Treatments — match_time","text":"Column names starting single point (e.g. names like \".variable\" \".id\") can used data, used internally, lead weird errors.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/match_time.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Matching for Causal Inference with Time-Dependent Treatments — match_time","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/match_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matching for Causal Inference with Time-Dependent Treatments — match_time","text":"","code":"library(data.table) library(MatchTime)  if (requireNamespace(\"survival\") & requireNamespace(\"MatchIt\") &     requireNamespace(\"ggplot2\")) {  library(survival) library(MatchIt) library(ggplot2)  # load some example data from the survival package data(\"heart\", package=\"survival\") heart$event <- as.logical(heart$event)  ## time-dependent matching, using \"transplant\" as treatment and only ## \"surgery\" as variable to match on, with \"event\" as outcome m.obj <- match_time(transplant ~ surgery, data=heart, id=\"id\",                     match_method=\"fast_exact\", outcomes=\"event\")  # show some balance statistics + the resulting sample sizes summary(m.obj)  # plot the number of cases / controls / potential controls over time plot(m.obj)  ## allow replacement of controls over time m.obj <- match_time(transplant ~ surgery, data=heart, id=\"id\",                     match_method=\"fast_exact\", replace_over_t=TRUE)  ## use nearest neighbor matching instead, matching also on continuous \"age\" # NOTE: this requires the \"MatchIt\" package m.obj <- match_time(transplant ~ surgery + age, data=heart, id=\"id\",                     match_method=\"nearest\") summary(m.obj) } #> Call: #> match_time(formula = transplant ~ surgery, data = heart, id = \"id\",  #>     outcomes = \"event\", match_method = \"fast_exact\") #>  #> Summary of Balance for Matched Data at Baseline: #>         Means Treated Means Control Std. Mean Diff. Var. Ratio  eCDF Mean #> age        -3.6512606   -2.81791771              NA         NA 0.05190854 #> year        3.5573209    3.10466195              NA         NA 0.05304895 #> surgery     0.1967213    0.08888889              NA         NA 0.10783242 #>          eCDF Max #> age     0.1222313 #> year    0.1266065 #> surgery 0.1078324 #>  #> Sample Sizes: #>           Controls Treated All #> Matched         53      53 106 #> Unmatched       15      16  31 #> Included       103      69 103 #> Supplied       103      69 103 #>  #> Points in Time: #> Matching was performed at 43 unique points in time between 1 and 310. #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Call: #> match_time(formula = transplant ~ surgery + age, data = heart,  #>     id = \"id\", match_method = \"nearest\") #>  #> Summary of Balance for Matched Data at Baseline: #>           Means Treated Means Control Std. Mean Diff. Var. Ratio  eCDF Mean #> eventTRUE     0.4745763     0.4883721              NA         NA 0.01379582 #> age          -2.5997517    -2.6059883              NA         NA 0.04105950 #> year          3.5534519     3.3669198              NA         NA 0.03444160 #> surgery       0.1864407     0.1162791              NA         NA 0.07016161 #>             eCDF Max #> eventTRUE 0.01379582 #> age       0.12105712 #> year      0.07416880 #> surgery   0.07016161 #>  #> Sample Sizes: #>           Controls Treated All #> Matched         51      51 102 #> Unmatched       17      18  35 #> Included       103      69 103 #> Supplied       103      69 103 #>  #> Points in Time: #> Matching was performed at 43 unique points in time between 1 and 310."},{"path":"https://robindenz1.github.io/MatchTime/reference/merge_start_stop.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge two or more datasets in the start-stop format — merge_start_stop","title":"Merge two or more datasets in the start-stop format — merge_start_stop","text":"Given multiple data.tables (similar objects) containing partial complete information time periods intervals (start-stop data), function creates single complete data.table start-stop format containing information. Single recurrent events may added. essentially faster RAM efficient version classic tmerge function survival package additional functionality. generic function S3 method, input data.tables.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/merge_start_stop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge two or more datasets in the start-stop format — merge_start_stop","text":"","code":"merge_start_stop(x, y, ..., dlist, by, start=\"start\",                  stop=\"stop\", all=FALSE, all.x=all,                  all.y=all, first_time=NULL, last_time=NULL,                  remove_before_first=TRUE,                  remove_after_last=TRUE,                  center_on_first=FALSE, units=\"auto\",                  defaults=NULL, event_times=NULL,                  time_to_first_event=FALSE,                  status=\"status\", constant_vars=NULL)"},{"path":"https://robindenz1.github.io/MatchTime/reference/merge_start_stop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge two or more datasets in the start-stop format — merge_start_stop","text":"x, y, ... data.table like objects (tibble, data.frame, ...) containing information time periods. contain information one variables created. data.table contain four columns: (individual identifier across data.tables), start (beginning interval), stop (end interval) least one variable containing values observed interval respective individual identified using . information given \"Details\". Users define either x y (potentially parse objects ...) define dlist argument instead. dlist list data.table like objects. argument may used instead parsing data.tables directly x, y three-dot syntax. dlist specified, x, y datasets parsed ... ignored. single character string specifying name column uniquely identifies individuals supplied datasets. column identified string may contain variable type. Contrary argument standard merge functions, argument support multiple values. Since goal merge time-intervals, also necessary additionaly define columns identify using start stop arguments. start single character string specifying name start column supplied datasets. Defaults \"start\". column identified string may contain variable type allows comparisons can merged (int, datetime, floats). stop single character string specifying name stop column supplied datasets. Defaults \"stop\". column identified string may contain variable type allows comparisons can merged (int, datetime, floats). Either TRUE FALSE (default). =TRUE shorthand save setting .x=TRUE .y=TRUE. .x Either TRUE FALSE. TRUE, cases x (identified using column) matching cases y dataset supplied afterwards ... included output (dlist specified, first entry dlist considered \"x\" entries \"y\"). cases NAs columns usually filled values datasets. default FALSE cases data x y (potentially datasets) included ouptut. analogous standard merge functions, difference datasets except x counted \"y\" datasets. arguments apply cases identified using column, time-intervals defined start stop. .y Either TRUE FALSE, analogous .x . first_time optional scalar value specifying time observation time starts individuals NULL (default). NULL, information given supplied data used construct start-stop data. specified, additional time-period added first_time first event time case (present already). Note argument must type start stop columns. last_time first_time, end observation period. remove_before_first Either TRUE (default) FALSE. TRUE first_time specified, time intervals first_time removed individual. done default first_time specified, can turned setting argument FALSE. remove_after_last Either TRUE (default) FALSE. TRUE last_time specified, time intervals last_time removed individual. done default last_time specified, can turned setting argument FALSE. center_on_first Either TRUE FALSE (default), specifying whether start stop columns centered first_time value. first_time specified center_on_first=TRUE, first time period case start 0 periods afterwards correspond time elapsed since . units Corresponds units argument difftime function. used start stop class Date (something similar) center_on_first set TRUE. Ignored otherwise. defaults optional named list containing default values variable NULL (default). NULL, missing information kept NA. argument may useful supplied datasets contain information time observation individuals. value defaults imputed missing intervals. See details examples. event_times optional data.table containing times event occured case NULL (default). NULL, events added. specified, times included data.table added resulting start-stop data form status variable. data reflect usually needed fit time--event recurrent event models. See details examples. supplied data.table include exactly two columns: (see argument name) time (time event(s) occured). Multiple events per case supported. Note event_times contains times first included time-period case, included output. Users define first_time argument accordingly, provide full information required time-periods supplied datasets. time_to_first_event Either TRUE FALSE (default), specifying whether observation time first event per case removed . TRUE, time first event per person kept. Event times defined using event_times argument. argument ignored event_times NULL. Note first_time specified first event case happens first included time period, case removed entirely output. status single character string specifying status variable named. Defaults \"status\". Ignored event_times=NULL. constant_vars optional data.table containing values variables constant time cases supplied data NULL (default). specified, constant variables simply merged final start-stop data. input constant_vars therefore contain column named argument.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/merge_start_stop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge two or more datasets in the start-stop format — merge_start_stop","text":"start-stop format, also known counting process period format corresponds data.table containing one multiple rows per , row corresponds period time variables changed. intervals defined start stop columns. start column gives time period started, stop column denotes time period ended. type dataset required match_time function existing time--event models time-varying variables, coxph. Bringing existing data period information format can become tricky computationally expensive fast. purpose function make transformation fast easy possible. Interval Coding Time-Varying Variables: intervals supplied function via x, y, ... dlist output created based entirely overlapping intervals. specifically, right-open intervals [start, stop) expected used throughout , usual data format expected time--event modelling corresponds interval format tmerge function survival package. consequence, intervals length 0 (start==stop) supported result error message. Note applies time-varying variables . Events added using event_times coded differently, described . Specifying input: input data.table include information time-periods one variables. example, suppose want include data two time-varying variables individual id=1. variables BMI Treatment measured different time intervals. Suppose following information BMI: words, BMI value 32.1 interval [0, 10) value 35 ín interval [10, 22). Additionally, know days treatment given: , actual days treatment recorded, known treatment given times. include information directly d2 adding intervals inbetween, need , see soon. two datasets merged one start-stop dataset using: example also given want run . specifying defaults argument \"Treatment\" FALSE, get desired start-stop dataset. using ... dlist argument, number data.tables full information (d1) partial information (d2) may merged. examples given . Inclusion Event Times: type start-stop data required time--event models time-varying variables recurrent events requires event times coded differently standard intervals. Instead creating new interval event time, existing intervals end event times, effectively breaking existing intervals (see example Chiou et al. 2023). can achieved function supplying event times separately using event_times argument. Multiple events per case supported. time first event kept, users may set time_to_first_event TRUE. first_time specified remove_before_first=TRUE, events occuring first_time removed well. time_to_first_event=TRUE used additionally, cases events first_time removed entirely. users want instead keep time first event first_time, required remove events point time event_times dataset calling function. Speed Considerations: Contrary similar functions tmerge function survival package, function rely ivs package perform data transformation. instead relies data.table package, highly optimized terms RAM usage performance. , function scales lot better large inputs (large amount cases many intervals). small datasets discernible difference functions. Note supplying datasets merged time faster calling function multiple times one x y , although might necessary latter certain situations","code":"d1 <- data.table(id=c(1, 1),                    start=c(0, 10),                    stop=c(10, 22),                    BMI=c(32.1, 35)) d2 <- data.table(id=c(1, 1, 1),                    start=c(3, 6, 12),                    stop=c(4, 7, 13),                    Treatment=c(TRUE, TRUE, TRUE)) data <- merge_start_stop(dl, d2, by=\"id\", defaults=list(\"Treatment\"=FALSE))"},{"path":"https://robindenz1.github.io/MatchTime/reference/merge_start_stop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge two or more datasets in the start-stop format — merge_start_stop","text":"Returns single data.table containing supplied information intervals start-stop format.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/merge_start_stop.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Merge two or more datasets in the start-stop format — merge_start_stop","text":"Sy Han Chiou, Gongjun Xu, Jun Yan, Chiung-Yu Huang (2023). \"Regression Modeling Recurrent Events Possibly Informative Terminal Event Using R Package reReg\". : Journal Statistical Software. 105.5, pp. 1-34.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/merge_start_stop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Merge two or more datasets in the start-stop format — merge_start_stop","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/merge_start_stop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge two or more datasets in the start-stop format — merge_start_stop","text":"","code":"library(MatchTime) library(data.table) library(fastmatch)  ## example from \"Details\" section # NOTE: actual data may of course include more than one unique \"id\" #       and more than two variables d1 <- data.table(id=c(1, 1),                  start=c(0, 10),                  stop=c(10, 22),                  BMI=c(32.1, 35))  d2 <- data.table(id=c(1, 1, 1),                  start=c(3, 6, 12),                  stop=c(4, 7, 13),                  Treatment=c(TRUE, TRUE, TRUE))  # setting default for Treatment data <- merge_start_stop(d1, d2, by=\"id\", defaults=list(\"Treatment\"=FALSE)) print(data) #> Key: <id, start> #>       id start  stop   BMI Treatment #>    <num> <num> <num> <num>    <lgcl> #> 1:     1     0     3  32.1     FALSE #> 2:     1     3     4  32.1      TRUE #> 3:     1     4     6  32.1     FALSE #> 4:     1     6     7  32.1      TRUE #> 5:     1     7    10  32.1     FALSE #> 6:     1    10    12  35.0     FALSE #> 7:     1    12    13  35.0      TRUE #> 8:     1    13    22  35.0     FALSE  # setting no such defaults data <- merge_start_stop(d1, d2, by=\"id\") print(data) #> Key: <id, start> #>       id start  stop   BMI Treatment #>    <num> <num> <num> <num>    <lgcl> #> 1:     1     0     3  32.1        NA #> 2:     1     3     4  32.1      TRUE #> 3:     1     4     6  32.1        NA #> 4:     1     6     7  32.1      TRUE #> 5:     1     7    10  32.1        NA #> 6:     1    10    12  35.0        NA #> 7:     1    12    13  35.0      TRUE #> 8:     1    13    22  35.0        NA  # with a first_time and last_time argument data <- merge_start_stop(d1, d2, by=\"id\", first_time=-5, last_time=100) print(data) #> Key: <id, start> #>        id start  stop   BMI Treatment #>     <num> <num> <num> <num>    <lgcl> #>  1:     1    -5     0    NA        NA #>  2:     1     0     3  32.1        NA #>  3:     1     3     4  32.1      TRUE #>  4:     1     4     6  32.1        NA #>  5:     1     6     7  32.1      TRUE #>  6:     1     7    10  32.1        NA #>  7:     1    10    12  35.0        NA #>  8:     1    12    13  35.0      TRUE #>  9:     1    13    22  35.0        NA #> 10:     1    22   100    NA        NA  # last_time < actually observed last time data <- merge_start_stop(d1, d2, by=\"id\", last_time=17) print(data) #> Key: <id, start> #>       id start  stop   BMI Treatment #>    <num> <num> <num> <num>    <lgcl> #> 1:     1     0     3  32.1        NA #> 2:     1     3     4  32.1      TRUE #> 3:     1     4     6  32.1        NA #> 4:     1     6     7  32.1      TRUE #> 5:     1     7    10  32.1        NA #> 6:     1    10    12  35.0        NA #> 7:     1    12    13  35.0      TRUE #> 8:     1    13    17  35.0        NA  # first_time > actually observed first time data <- merge_start_stop(d1, d2, by=\"id\", first_time=8) print(data) #> Key: <id, start> #>       id start  stop   BMI Treatment #>    <num> <num> <num> <num>    <lgcl> #> 1:     1     8    10  32.1        NA #> 2:     1    10    12  35.0        NA #> 3:     1    12    13  35.0      TRUE #> 4:     1    13    22  35.0        NA  # adding a time-constant variable sex d3 <- data.table(id=1, sex=\"female\") data <- merge_start_stop(d1, d2, by=\"id\", constant_vars=d3) print(data) #> Key: <id> #>       id start  stop   BMI Treatment    sex #>    <num> <num> <num> <num>    <lgcl> <char> #> 1:     1     0     3  32.1        NA female #> 2:     1     3     4  32.1      TRUE female #> 3:     1     4     6  32.1        NA female #> 4:     1     6     7  32.1      TRUE female #> 5:     1     7    10  32.1        NA female #> 6:     1    10    12  35.0        NA female #> 7:     1    12    13  35.0      TRUE female #> 8:     1    13    22  35.0        NA female  # adding event times d4 <- data.table(id=c(1, 1), time=c(4, 31)) data <- merge_start_stop(d1, d2, by=\"id\", event_times=d4) print(data) #> Key: <id> #>       id start  stop   BMI Treatment status #>    <num> <num> <num> <num>    <lgcl> <lgcl> #> 1:     1     0     3  32.1        NA  FALSE #> 2:     1     3     4  32.1      TRUE   TRUE #> 3:     1     4     6  32.1        NA  FALSE #> 4:     1     6     7  32.1      TRUE  FALSE #> 5:     1     7    10  32.1        NA  FALSE #> 6:     1    10    12  35.0        NA  FALSE #> 7:     1    12    13  35.0      TRUE  FALSE #> 8:     1    13    22  35.0        NA  FALSE #> 9:     1    22    31    NA        NA   TRUE"},{"path":"https://robindenz1.github.io/MatchTime/reference/method_brsm.html","id":null,"dir":"Reference","previous_headings":"","what":"Balanced Risk Set Matching — method_brsm","title":"Balanced Risk Set Matching — method_brsm","text":"documentation page describes matching process used setting method=\"brsm\" match_time function. additional arguments supported case.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_brsm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Balanced Risk Set Matching — method_brsm","text":"Balanced risk set matching first proposed Li et al. (2005) also known sequential stratification proposed Schaubel et al. (2006). works first identifying times point treatment status individual switches \"control\" \"treated\" sorting first last. matching performed subsequently distinct points time. individuals whose treatment status changed \"control\" \"treated\" \\(t\\) included matched data \"cases\". included individual, ratio controls choosen individuals yet receive treatment \\(t\\) also included matched data. controls choosen either random (match_method=\"none\") matching supplied covariates using one available match_methods. time inclusion considered \"time-zero\" individuals included way. methods implemented package use essentially methodology. differ controls matched cases.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_brsm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Balanced Risk Set Matching — method_brsm","text":"Li, Yunfei Pail, Kathleen J. Propert, Paul R. Rosenbaum (2001). \"Balanced Risk Set Matching\". : Journal American Statistical Association 96.455, pp. 870-882. Schaubel, Douglas E., Robert . Wolfe, Friedrich K. Port (2006). \"Sequential Stratification Method Estimating Effect Time-Dependent Experimental Treatment Observational Studies\". : Biometrics 62, pp. 910-917. Thomas, Laine E., Siyun Yang, Daniel Wojdyla, Douglas E. Schaubel (2020). \"Matching Time-Dependent Treatments: Review Look Forward\". : Statistics Medicine 39, pp. 2350-2370.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_brsm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Balanced Risk Set Matching — method_brsm","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_brsm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Balanced Risk Set Matching — method_brsm","text":"","code":"library(data.table) library(MatchTime)  if (requireNamespace(\"survival\") & requireNamespace(\"MatchIt\") &     requireNamespace(\"ggplot2\")) {  library(survival) library(MatchIt) library(ggplot2)  # load some example data from the survival package data(\"heart\", package=\"survival\")  # keep only columns relevant for matching heart <- heart[, c(\"id\", \"start\", \"stop\", \"transplant\", \"age\", \"surgery\")]  ## time-dependent matching, using \"transplant\" as treatment and only ## \"surgery\" as variable to match on m.obj <- match_time(transplant ~ surgery, data=heart, id=\"id\",                     match_method=\"fast_exact\") }"},{"path":"https://robindenz1.github.io/MatchTime/reference/method_dsm.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-Dependent Double Score Matching — method_dsm","title":"Time-Dependent Double Score Matching — method_dsm","text":"documentation page describes matching process used setting method=\"dsm\" match_time function gives detailed explanation supported additional arguments case.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_dsm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time-Dependent Double Score Matching — method_dsm","text":"formula_ps optional formula object, specifying right-hand side formula used propensity score model, NULL (default). NULL, right-hand side formula argument used fit model. argument useful mostly specify interactions, non-linear effects similar thing. Note formula object start ~ nothing left-hand side. formula_prog formula_ps used propensity score model. event single character string specifying column data containing event status interest. outcome specified argument used dependent variable prognostic score model. argument therefore must specified, otherwise error produced. Note argument treated outcome default added outcomes main function call. ps_type single character string, specifying type \"propensity score\" use. Currently supports \"ps\", results usage actual propensity score time t \"lp\", instead uses linear predictor model (disregarding baseline hazard), proposed Hade et al. (2015). Using \"lp\" faster baseline hazard need estimated need calculate actual propensity score time matching done. , however, currently studies showing \"lp\" method performs well \"ps\" method, recommended keep \"ps\". prog_type single character string, specifying type \"prognostic score\" use. Currently supports \"p\", results usage outcome probability time t \"lp\", instead uses linear predictor model (disregarding baseline hazard). Using \"lp\" faster baseline hazard need estimated need calculate actual probability time matching done. , however, currently studies showing \"lp\" method performs well \"p\" method, recommended keep \"p\". standardize_ps Either TRUE FALSE (default), specifying whether standardize \"propensity score\" specified ps_type 0 / 1 range. might beneficial matching strategies , example, used Richey et al. (2024). standardize_prog Either TRUE FALSE (default), specifying whether standardize \"prognostic score\" specified prog_type 0 / 1 range. might beneficial matching strategies. basehaz_interpol single character string controlling estimated baseline hazard interpolated. used type_ps=\"ps\" / type_prog=\"p\", case baseline hazard estimated fitted Cox model(s) using basehaz function survival package. Allowed values \"constant\" (default) step function interpolation (usual survival curves) \"linear\" linear interpolation. usually kept \"constant\". Interpolation performed internally using approxfun function rule=2. remove_ps Either TRUE FALSE (default), specifying whether estimated propensity score removed data. FALSE, propensity score .treat_time included .ps_score column. remove_prog Either TRUE FALSE (default), specifying whether estimated prognostic score removed data. FALSE, prognostic score .treat_time included .ps_score column.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_dsm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Time-Dependent Double Score Matching — method_dsm","text":"arguments match_time function may used using method=\"dsm\", general sequential nature matching. difference matching process matching performed directly covariates formula, instead done estimated time-dependent prognostic score time-dependent propensity score point time. works: method combines time-dependent propensity score matching (see method_psm) time-dependent prognostic score matching (see method_pgm) single doubly-robust method estimating scores matching . Doubly-robust case means one two models correctly specified obtain unbiased estimates matching. property studied quite well regular double risk score matching (see Antonelli et al. 2018 Leacy et al. 2014), lot literature time-dependent case. notable exception Li et al (2013). match_time allows users use matchit function internally, many possible options exactly matching performed. Users , example, use caliper based matching scores simply combine using mahalanobis distance, described Estimation propensity prognostic score: scores estimated exactly way estimated using method=\"psm\" method=\"pgm\". Please consult documentation page methods details.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_dsm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-Dependent Double Score Matching — method_dsm","text":"Li, Yun, Douglas E. Schaubel, Kevin (2013). \"Matching Methods Obtaining Survival Functions Estimate Effect Time-Dependent Treatment\". : Statistics Biosciences 6, pp. 105-126. Antonelli, Joseph, Matthew Cefalu, Nathan Palmer, Denis Agniel (2018). \"Doubly Robust Matching Estimators High Dimensional Confounding Adjustment\". : Biometrics 74, pp. 1171-1179. Leacy, Finbarr P. Elizabeth . Stuart (2014). \"Joint Use Propensity Prognostic Scores Estimation Average Treatment Effect Treated: Simulation Study\". : Statistics Medicine 33.20, pp. 3488-3508. Zhang, Yunshu, Shu Yanh, Wenyu Ye, Douglas E. Faries, Ilya Lipkovich, Zbigniew Kadziola (2022). \"Practical Recommendations Double Score Matching Estimating Causal Effects\". : Statistics Medicine 41, pp. 1421-1445.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_dsm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Time-Dependent Double Score Matching — method_dsm","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_dsm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-Dependent Double Score Matching — method_dsm","text":"","code":"library(data.table) library(MatchTime)  if (requireNamespace(\"survival\") & requireNamespace(\"MatchIt\") &     requireNamespace(\"ggplot2\")) {  library(survival) library(MatchIt) library(ggplot2)  # load some example data from the survival package data(\"heart\", package=\"survival\")  ## time-dependent double score matching, using \"transplant\" as treatment ## and surgery + age as variables to match on m.obj <- match_time(transplant ~ surgery + age, data=heart, id=\"id\",                     method=\"dsm\", event=\"event\", match_method=\"nearest\",                     replace_over_t=TRUE)  # showing a summary of the used propensity score model summary(m.obj$ps_model)  # showing a summary of the used prognostic score model summary(m.obj$prog_model) } #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Call: #> survival::coxph(formula = stats::as.formula(cox_form), data = d_outcome) #>  #>   n= 103, number of events= 30  #>  #>             coef exp(coef) se(coef)      z Pr(>|z|) #> surgery -0.56342   0.56926  0.61405 -0.918    0.359 #> age      0.01458   1.01469  0.01843  0.791    0.429 #>  #>         exp(coef) exp(-coef) lower .95 upper .95 #> surgery    0.5693     1.7567    0.1709     1.897 #> age        1.0147     0.9855    0.9787     1.052 #>  #> Concordance= 0.573  (se = 0.063 ) #> Likelihood ratio test= 1.52  on 2 df,   p=0.5 #> Wald test            = 1.4  on 2 df,   p=0.5 #> Score (logrank) test = 1.43  on 2 df,   p=0.5 #>"},{"path":"https://robindenz1.github.io/MatchTime/reference/method_greedy.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-Dependent Greedy Selection of Controls — method_greedy","title":"Time-Dependent Greedy Selection of Controls — method_greedy","text":"documentation page describes matching process used setting method=\"greedy\" match_time function gives explanation arguments may still used case. additional arguments currently supported using method.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_greedy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Time-Dependent Greedy Selection of Controls — method_greedy","text":"Due nature approach, almost none arguments match_time function may used using method=\"greedy\", make sense context greedy selection controls. specifically, arguments formula, data, id, inclusion, start, stop, method, replace_cases verbose can used method. works: methods implemented package use sort matching select pre-specified number controls pool available data. using method=\"greedy\", case. Instead performing selection, every single individual eligible control point time \"matching\" occurs selected control. example, suppose \\(t = 10\\) 100 individuals dataset. individuals, 20 receive treatment first time \\(t\\) 10 already received treatment \\(t\\). remaining 70 individuals eligible sampled controls point time (fufill inclusion criteria) thus used controls. process repeated point time least one individual switches control treated condition. selection controls proceeds replace_at_t=TRUE, regardless value supplied argument. Replacement controls time neccessary, otherwise woule controls left first time individual receives treatment. method might seem odd first, Gran et al. (2010) shown, work quite well estimands interest analysis done appropriate manner. authors propose following three step analysis: (1) censoring controls whenever later receive treatment (implemented argument censor_at_treat add_outcome function), (2) calculating inverse probability censoring weights \"trial\" (.treat_time), (3) using stratified weighted Cox model perform actual confounder adjustment.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_greedy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-Dependent Greedy Selection of Controls — method_greedy","text":"Gran, Jon Michael, Kjetil Røysland, Marcel Wolbers, Vanessa Didelez, Jonathan . C. Sterne, Bruno Ledergerber, Hansjakob Furrer, Viktor von Wyl, Odd O. Aalen (2010). \"Sequential Cox Approach Estimating Causal Effect Treatment Presence Time-Dependent Confounding Applied Data Swiss HIV Cohort Study\". : Statistics Medicine 29, pp. 2757-2768. Karim, Mohammad Ehsanul, John Petkau, Paul Gustafson, Robert W. Platt, Helen Tremlett (2018). \"Comparison Statistical Approaches Dealing Time-Dependent Confounding Drug Effectiveness Studies\". : Statistical Methods Medical Research 27.6, pp. 1709-1722.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_greedy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Time-Dependent Greedy Selection of Controls — method_greedy","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_greedy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-Dependent Greedy Selection of Controls — method_greedy","text":"","code":"library(data.table) library(MatchTime)  if (requireNamespace(\"survival\")) {  library(survival)  # load some example data from the survival package data(\"heart\", package=\"survival\")  ## time-dependent greedy matching ## there does not have to be anything on the RHS of formula, because no ## actual matching is performed m.obj <- match_time(transplant ~ 1, data=heart, id=\"id\",                     method=\"greedy\") }"},{"path":"https://robindenz1.github.io/MatchTime/reference/method_pgm.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-Dependent Prognostic Score Matching — method_pgm","title":"Time-Dependent Prognostic Score Matching — method_pgm","text":"documentation page describes matching process used setting method=\"pgm\" match_time function gives detailed explanation supported additional arguments case.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_pgm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time-Dependent Prognostic Score Matching — method_pgm","text":"event single character string specifying column data containing event status interest. outcome specified argument used dependent variable prognostic score model. argument therefore must specified, otherwise error produced. Note argument treated outcome default added outcomes main function call. formula_prog optional formula object, specifying right-hand side formula used outcome model, NULL (default). NULL, right-hand side formula argument used fit model. argument useful mostly specify interactions, non-linear effects similar thing. Note formula object start ~ nothing left-hand side. prog_type single character string, specifying type \"prognostic score\" use. Currently supports \"p\", results usage hazard outcome time \\(t\\) \"lp\", instead uses linear predictor model (disregarding baseline hazard). Using \"lp\" faster baseline hazard need estimated need calculate actual hazard time matching done. See details. standardize_prog Either TRUE FALSE (default), specifying whether standardize \"prognostic score\" specified prog_type 0 / 1 range. might beneficial matching strategies. basehaz_interpol single character string controlling estimated baseline hazard interpolated. used type_prog=\"p\", case baseline hazard estimated fitted prognostic score Cox model using basehaz function survival package. Allowed values \"constant\" (default) step function interpolation (usual survival curves) \"linear\" linear interpolation. usually kept \"constant\". Interpolation performed internally using approxfun function rule=2. remove_prog Either TRUE FALSE (default), specifying whether estimated prognostic score removed data. FALSE, prognostic score .treat_time included .prog_score column.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_pgm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Time-Dependent Prognostic Score Matching — method_pgm","text":"arguments match_time function may used using method=\"pgm\", general sequential nature matching. difference matching process matching performed directly covariates formula, instead done estimated time-dependent prognostic score point time. works: Time-dependent prognostic score matching similar popular time-dependent propensity score matching (method=\"psm\"). works first estimating probability individual experience outcome event t, given individual yet experienced event point given individual yet receive treatment. essentially just estimate conditional survival probability, standard quantity time--event analysis. Hansen (2008) showed matching score result unbiased estimates causal effect interest. results extended time-dependent context et al. (2020) authors (cited ). might seem weird first. , one main reasons using time-dependent matching avoids fitting outcome models. Cox models time-dependent variables also generally allow estimation marginal effects presence treatment-outcome feedback complex causal feedback loops. important thing keep mind fitted outcome model used actually estimate effects. pure nuisance model, used predict conditional hazard outcome given covariates control conditions, require many assumptions actual causal analysis. Estimation prognostic score: prognostic score estimated using Cox model actual outcome interest dependent variable first step. variables RHS formula used independent variables (time-fixed time-dependent ones). Importantly, time control conditions individuals used model. Individuals receive treatment point observation period artificially censored point time. model therefore include treatment status covariate. hazard experiencing outcome event, e.g. time-dependent prognostic score, calculated individuals point matching performed. matching done entirely using prognostic score, ignoring covariates. model used predict prognostic scores included output object whenever method=\"pgm\" used. Formally, model can described : $$h_Y(t) = h_{Y0}(t) e^{\\beta X(t)},$$ \\(X(t)\\) refers arbitrary amount (possibly) time-dependent covariates. matching done either \\(\\hat{h}_Y(t)\\) (using prog_type=\"p\") linear predictor \\(e^{\\beta X(t)}\\) (using prog_type=\"lp\"). explained ?method_psm, makes difference strata terms included Cox model formula, case default \"p\" preferred. Interval Coding: event column data used outcome Cox model described , ' intervals coded standard time--event outcome way described survival package. means instead new intervals starting occurence event, existing intervals broken event times event 1 TRUE exactly times. One option create data use merge_start_stop function package appropriate input event_times argument.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_pgm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-Dependent Prognostic Score Matching — method_pgm","text":"Hansen, Ben B. (2008). \"Prognostic Analogue Propensity Score\". : Biometrika 95.2, pp. 481-488. , Kevin, Yun Li, Panduranga S. Rao, Randall S. Sung, Douglas E. Schaubel (2020). \"Prognostic Score Matching Methods Estimating Average Effect Non-Reversible Binary Time-Dependent Treatment Survival Function\". : Lifetime Data Analysis 26, pp. 451-470. Li, Yun, Douglas E. Schaubel, Kevin (2013). \"Matching Methods Obtaining Survival Functions Estimate Effect Time-Dependent Treatment\". : Statistics Biosciences 6, pp. 105-126. Smith, Abigail R. Douglas E. Schaubel (2015). \"Time-Dependent Prognostic Score Matching Recurrent Event Analysis Evaluate Treatment Assigned Follow-\". : Biometrics 71, pp. 950-959.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_pgm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Time-Dependent Prognostic Score Matching — method_pgm","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_pgm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-Dependent Prognostic Score Matching — method_pgm","text":"","code":"library(data.table) library(MatchTime)  if (requireNamespace(\"survival\") & requireNamespace(\"MatchIt\") &     requireNamespace(\"ggplot2\")) {  library(survival) library(MatchIt) library(ggplot2)  # load some example data from the survival package data(\"heart\", package=\"survival\")  ## time-dependent prognostic score matching, using \"transplant\" as treatment ## and surgery + age as variables to match on m.obj <- match_time(transplant ~ surgery + age, data=heart, id=\"id\",                     method=\"pgm\", event=\"event\", match_method=\"nearest\",                     replace_over_t=TRUE)  # showing a summary of the used prognostic score model summary(m.obj$prog_model) } #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Call: #> survival::coxph(formula = stats::as.formula(cox_form), data = d_outcome) #>  #>   n= 103, number of events= 30  #>  #>             coef exp(coef) se(coef)      z Pr(>|z|) #> surgery -0.56342   0.56926  0.61405 -0.918    0.359 #> age      0.01458   1.01469  0.01843  0.791    0.429 #>  #>         exp(coef) exp(-coef) lower .95 upper .95 #> surgery    0.5693     1.7567    0.1709     1.897 #> age        1.0147     0.9855    0.9787     1.052 #>  #> Concordance= 0.573  (se = 0.063 ) #> Likelihood ratio test= 1.52  on 2 df,   p=0.5 #> Wald test            = 1.4  on 2 df,   p=0.5 #> Score (logrank) test = 1.43  on 2 df,   p=0.5 #>"},{"path":"https://robindenz1.github.io/MatchTime/reference/method_psm.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-Dependent Propensity Score Matching — method_psm","title":"Time-Dependent Propensity Score Matching — method_psm","text":"documentation page describes matching process used setting method=\"psm\" match_time function gives detailed explanation supported additional arguments case.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_psm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time-Dependent Propensity Score Matching — method_psm","text":"formula_ps optional formula object, specifying right-hand side formula used propensity score model, NULL (default). NULL, right-hand side formula argument used fit model. argument useful mostly specify interactions, non-linear effects similar thing. Note formula object start ~ nothing left-hand side. ps_type single character string, specifying type \"propensity score\" use. Currently supports \"ps\", results usage actual hazard treatment time \\(t\\) \"lp\", instead uses linear predictor model (disregarding baseline hazard), proposed Hade et al. (2015). Using \"lp\" faster baseline hazard need estimated need calculate actual hazard time matching done. See details. standardize_ps Either TRUE FALSE (default), specifying whether standardize \"propensity score\" specified ps_type 0 / 1 range. might beneficial matching strategies , example, used Richey et al. (2024). basehaz_interpol single character string controlling estimated baseline hazard interpolated. used type_ps=\"ps\", case baseline hazard estimated fitted propensity score Cox model using basehaz function survival package. Allowed values \"constant\" (default) step function interpolation (usual survival curves) \"linear\" linear interpolation. usually kept \"constant\". Interpolation performed internally using approxfun function rule=2. remove_ps Either TRUE FALSE (default), specifying whether estimated propensity score removed data. FALSE, propensity score .treat_time included .ps_score column.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_psm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Time-Dependent Propensity Score Matching — method_psm","text":"arguments match_time function may used using method=\"psm\", general sequential nature matching. difference matching process matching performed directly covariates formula, instead done estimated time-dependent propensity score point time. works: propensity score usually defined probability individual receives treatment. case time-dependent treatment, propensity score instead defined probability individual receives treatment time t, given individual yet received treatment point. equivalent survival probability, outcome treatment interest, outcome interest. matching individuals score instead covariates directly, groups balanced points time (Lu 2005). Estimation Propensity Score: \"propensity score\" estimated using Cox model treatment variable dependent variable first step. practice, hazard receiving treatment calculated individuals point matching performed. Although technically regular propensity score, actual probability 0 1, referred time-dependent propensity score literature. matching done entirely using propensity score, ignoring covariates. may cases faster alternative matching many covariates time. model used predict propensity scores included output object whenever method=\"psm\" used. Formally, following Cox model, hazard receiving treatment \\(\\) given : $$h_A(t) = h_{A0}(t) e^{\\beta X(t)},$$ \\(h_{A0}(t)\\) baseline hazard \\(X(t)\\) stands arbitrary amount (possibly) time-dependent covariates. default (ps_type=\"ps\"), estimated hazard treatment \\(t\\) \\(\\left(\\hat{h}_{}(t)\\right)\\) used matching. Internally, basehaz function simply called Cox model estimate \\(h_{A0}(t)\\). strata terms formula used fit model, baseline hazard individuals \\(t\\), case equivalent use ps_type=\"lp\", case linear predictor \\(\\left(e^{\\beta X(t)}\\right)\\) used matching.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_psm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Time-Dependent Propensity Score Matching — method_psm","text":"Lu, Bo (2005). \"Propensity Score Matching Time-Dependent Covariates\". : Biometrics 61.3, pp. 721-728. Hade, Erinn M., Giovannie Nattino, Heather . Frey, Bo Lu (2020). \"Propensity Score Matching Treatment Delay Effects Observational Survival Data\". : Statistical Methods Medical Research 29.3, pp. 695-708. Richey, Morgan, Matthew Mayiejewski, Lindsay Tepel, David Arterburn, Aniket Kawatkar, Caroline E. Sloan, Valerie . Smith (2024). \"Comparison Time-Varying Propensity Score vs Sequential Stratification Approaches Longitudinal Matching Time-Varying Treatment\". : BMC Medical Research Methodology 24.280.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_psm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Time-Dependent Propensity Score Matching — method_psm","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/method_psm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-Dependent Propensity Score Matching — method_psm","text":"","code":"library(data.table) library(MatchTime)  if (requireNamespace(\"survival\") & requireNamespace(\"MatchIt\") &     requireNamespace(\"ggplot2\")) {  library(survival) library(MatchIt) library(ggplot2)  # load some example data from the survival package data(\"heart\", package=\"survival\")  # keep only columns relevant for matching heart <- heart[, c(\"id\", \"start\", \"stop\", \"transplant\", \"age\", \"surgery\")]  ## time-dependent propensity score matching, using \"transplant\" as treatment ## and surgery + age as variables to match on m.obj <- match_time(transplant ~ surgery + age, data=heart, id=\"id\",                     method=\"psm\", match_method=\"nearest\",                     replace_over_t=TRUE)  # showing a summary of the used propensity score model summary(m.obj$ps_model) } #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Call: #> survival::coxph(formula = stats::as.formula(cox_form), data = d_ps_mod) #>  #>   n= 69, number of events= 69  #>    (34 observations deleted due to missingness) #>  #>               coef  exp(coef)   se(coef)      z Pr(>|z|) #> surgery -0.3621390  0.6961856  0.3105484 -1.166    0.244 #> age      0.0008046  1.0008049  0.0143960  0.056    0.955 #>  #>         exp(coef) exp(-coef) lower .95 upper .95 #> surgery    0.6962     1.4364    0.3788     1.280 #> age        1.0008     0.9992    0.9730     1.029 #>  #> Concordance= 0.549  (se = 0.039 ) #> Likelihood ratio test= 1.46  on 2 df,   p=0.5 #> Wald test            = 1.36  on 2 df,   p=0.5 #> Score (logrank) test = 1.38  on 2 df,   p=0.5 #>"},{"path":"https://robindenz1.github.io/MatchTime/reference/plot.match_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot cumulative number of matched cases and controls — plot.match_time","title":"Plot cumulative number of matched cases and controls — plot.match_time","text":"Given match_time object created using match_time function, plot method displays cumulative number included cases, cumulative number matched controls number potential controls available observed time range.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot.match_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot cumulative number of matched cases and controls — plot.match_time","text":"","code":"# S3 method for class 'match_time' plot(x,      include=c(\"cases\", \"controls\", \"potential_controls\"),      xlab=\"Time\", ylab=\"Number\",      gg_theme=ggplot2::theme_bw(),      linealpha=1, linetype=\"solid\", linewidth=0.5,      ...)"},{"path":"https://robindenz1.github.io/MatchTime/reference/plot.match_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot cumulative number of matched cases and controls — plot.match_time","text":"x match_time object created using match_time function. include character vector including one \"cases\", \"controls\" \"potential_controls\". Controls whether plot contain cumulative number cases, cumulative number controls number potential controls t respectively. xlab single character string specifying label x-axis, defaults \"Time\". ylab single character string specifying label y-axis, defaults \"Number\". gg_theme ggplot2 theme used plot. linealpha single numeric value specifying transparency level lines. linetype single character string specifying type drawn lines. linewidth single numeric value specifying width drawn lines. ... Currently used.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot.match_time.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot cumulative number of matched cases and controls — plot.match_time","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot.match_time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot cumulative number of matched cases and controls — plot.match_time","text":"ratio=1 used matching successful cases, cumulative number cases cumulative number events exactly points time, meaning curves top . plot method therefore offers simple fast way check whether (, ) issues finding suitable controls ocurred. uses $trace object included input x create plot. Since returns standard ggplot2 object, can easily customized users. Note displayed number cases actual number cases t supplied data, fufilled inclusion criteria () point time, number cases received matches point time.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot.match_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot cumulative number of matched cases and controls — plot.match_time","text":"Returns ggplot2 object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/plot.match_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot cumulative number of matched cases and controls — plot.match_time","text":"","code":"library(data.table) library(MatchTime)  # only execute if packages are available if (requireNamespace(\"survival\") & requireNamespace(\"ggplot2\") &     requireNamespace(\"MatchIt\")) {  library(survival) library(ggplot2) library(MatchIt)  # set random seed to make the output replicably set.seed(1234)  # load \"heart\" data from survival package data(\"heart\")  # perform nearest neighbor time-dependent matching on \"age\" and \"surgery\" # (plus exact matching on time) out <- match_time(transplant ~ age + surgery, data=heart, id=\"id\",                   match_method=\"nearest\")  # plot all three statistics over time # NOTE: here we can see that the green line (cum. no. matched controls) #       and the red line (cum. no. cases) is exactly the same up until #       around t = 45, at which point no controls are left (blue line at 0) #       the number of cases still grows, but no controls are matched anymore plot(out)  # plot only controls and cases plot(out, include=c(\"cases\", \"controls\")) } #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred"},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_flowchart.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a flowchart of the sample size flow in a match_time object — plot_flowchart","title":"Plot a flowchart of the sample size flow in a match_time object — plot_flowchart","text":"function attempt creating CONSORT style flowchart sequential time-dependent matching methods implemented package. shows number potential cases potential controls filtered throughout matching process. included numbers may seem confusing first glance. See details information.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_flowchart.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a flowchart of the sample size flow in a match_time object — plot_flowchart","text":"","code":"plot_flowchart(   x,   digits=2,   n_fontface=\"italic\",   inclusion_text=NULL,   remove_0_lines=TRUE,   remove_0_boxes=FALSE,   perc_inclusion=TRUE,   perc_inclusion_total=FALSE,   perc_other=FALSE,   perc_type=\"all\",   number_format=format,   box_main_style=\"n_last\",   box_main_text=list(),   box_main_halign=0.5,   box_main_nudge_x=0,   box_main_nudge_y=0,   box_main_padding=ggplot2::unit(c(5.5, 5.5, 5.5, 5.5), \"pt\"),   box_main_margin=ggplot2::unit(c(0, 0, 0, 0), \"pt\"),   box_main_r=ggplot2::unit(5.5, \"pt\"),   box_main_width=ggplot2::unit(2, \"inch\"),   box_main_minwidth=NULL,   box_main_maxwidth=NULL,   box_main_height=NULL,   box_main_minheight=NULL,   box_main_maxheight=NULL,   box_main_colour=\"black\",   box_main_fill=\"lightblue\",   box_sec_text=list(),   box_sec_halign=0,   box_sec_nudge_x=box_main_nudge_x,   box_sec_nudge_y=box_main_nudge_y,   box_sec_padding=box_main_padding,   box_sec_margin=box_main_margin,   box_sec_r=box_main_r,   box_sec_width=box_main_width,   box_sec_minwidth=box_main_minwidth,   box_sec_maxwidth=box_main_maxwidth,   box_sec_height=box_main_height,   box_sec_minheight=box_main_minheight,   box_sec_maxheight=box_main_maxheight,   box_sec_colour=box_main_colour,   box_sec_fill=\"cornsilk\",   line_main_colour=\"black\",   line_main_linetype=\"solid\",   line_main_linewidth=0.5,   line_sec_colour=line_main_colour,   line_sec_linetype=\"dashed\",   line_sec_linewidth=line_main_linewidth,   arrow=TRUE,   arrow_type=\"closed\",   arrow_angle=30,   arrow_vjust=-0.4,   arrow_size=0.1,   xlim=c(-20, 20),   ylim=c(-6, 11),   ... )"},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_flowchart.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a flowchart of the sample size flow in a match_time object — plot_flowchart","text":"x match_time object created using match_time function. digits single integer, specifying number digits percentages rounded . n_fontface Either TRUE FALSE, specifying whether \"n = X\" texts main boxes \"normal\", \"italic\", \"bold\" \"bolditalic\". inclusion_text named list specifying text used exclusion criteria reasons. list contain names used inclusion criteria inclusion argument match_time function. remove_0_lines Either TRUE FALSE, specifying whether lines 0 occurrences removed secondary boxes. remove_0_boxes Either TRUE FALSE, specifying whether boxes basically empty 0 occurrences removed plot. perc_inclusion Either TRUE FALSE, specifying whether percentages shown individual exclusion criteria reasons. percentages use reference can controlled using perc_type argument. perc_inclusion_total Either TRUE FALSE, specifying whether percentages shown total numbers individuals excluded inclusion criteria. perc_other Either TRUE FALSE, specifying whether percentages shown numbers side-boxes related inclusion criteria. perc_type single character string controlling calculated percentages inclusion criteria items reference . \"\", percentages reference previous main box, e.g. percentage people fulfilling inclusion criteria X people applied . \"excluded\" percentage reference number individuals excluded due inclusion criteria instead. number_format function can called vector numbers outputs numbers strings form. can used ensure number digits shown regardless number, break large numbers commas points. Defaults format function. arguments function may passed ... syntax. box_main_style single character string, controlling \"style\" text main boxes . either \"n_first\", case numbers appear text, \"n_last\" numbers appear text (default). box_main_text named list single character strings, specifying alternative text defaults printed main boxes. names list one \"box1\" (defining text first box top), \"box2l\" (defining text second box top left), \"box2r\" (defining text second box top right), \"box3l\" (defining text third box top left), \"box3r\" (defining text third box top right), \"box4l\" (fourth box left), \"box4r\" (fourth box right). Set list() change text (default). box_main_halign Passed halign aesthetic geom_textbox function used main boxes. box_main_nudge_x Passed nudge_x argument geom_textbox function used main boxes. box_main_nudge_y Passed nudge_y argument geom_textbox function used main boxes. box_main_padding Passed box.padding argument geom_textbox function used main boxes. box_main_margin Passed box.margin argument geom_textbox function used main boxes. box_main_r Passed box.r argument geom_textbox function used main boxes. box_main_width Passed width argument geom_textbox function used main boxes. box_main_minwidth Passed minwidth argument geom_textbox function used main boxes. box_main_maxwidth Passed maxwidth argument geom_textbox function used main boxes. box_main_height Passed height argument geom_textbox function used main boxes. box_main_minheight Passed minheight argument geom_textbox function used main boxes. box_main_maxheight Passed maxheight argument geom_textbox function used main boxes. box_main_colour Passed box.colour aesthetic geom_textbox function used main boxes. box_main_fill Passed fill aesthetic geom_textbox function used main boxes. box_sec_text named list single character strings, specifying alternative text defaults printed secondary boxes. names list one \"box1l\" (defining text first secondary box top left side), \"box1r\" (defining text first secondary box top right), \"box2l1\" (defining text unmatched second secondary box top left side), \"box2l2\" (defining text inclusion criteria second secondary box top left side), \"box2r1\" (defining text many controls used bottom right box), \"box2r2\" (defining text many controls used bottom right box). Set list() change text (default). box_sec_halign Passed halign aesthetic geom_textbox function used secondary boxes. box_sec_nudge_x Passed nudge_x argument geom_textbox function used secondary boxes. box_sec_nudge_y Passed nudge_y argument geom_textbox function used secondary boxes. box_sec_padding Passed box.padding argument geom_textbox function used secondary boxes. box_sec_margin Passed box.margin argument geom_textbox function used secondary boxes. box_sec_r Passed box.r argument geom_textbox function used secondary boxes. box_sec_width Passed width argument geom_textbox function used secondary boxes. box_sec_minwidth Passed minwidth argument geom_textbox function used secondary boxes. box_sec_maxwidth Passed maxwidth argument geom_textbox function used secondary boxes. box_sec_height Passed height argument geom_textbox function used secondary boxes. box_sec_minheight Passed minheight argument geom_textbox function used secondary boxes. box_sec_maxheight Passed maxheight argument geom_textbox function used secondary boxes. box_sec_colour Passed box.colour argument geom_textbox function used secondary boxes. box_sec_fill Passed fill argument geom_textbox function used secondary boxes. line_main_colour colour main lines connecting main boxes. line_main_linetype type lines connecting main boxes. line_main_linewidth width lines connecting main boxes. line_sec_colour color lines connecting secondary boxes main lines. line_sec_linetype type lines connecting secondary boxes main lines. line_sec_linewidth width lines connecting secondary boxes main lines. arrow Either TRUE FALSE, specifying whether draw arrows main lines. arrow_type angle arrow head degrees (smaller numbers produce narrower, pointier arrows). Essentially describes width arrow head. Ignored arrow=FALSE. arrow_angle type arrow heads drawn, ignored arrow=FALSE. arrow_vjust single number may used shift arrow heads . probably needed order correctly place arrows. work, users encouraged set arrow=FALSE add arrows using geom_segment function. arrow_size size drawn arrow heads, ignored arrow=FALSE. xlim x limits plot. usually stay values given , positions boxes hard-coded. can, however, changed allow drawing boxes etc. change size boxes, arguments starting box_main_ box_sec_ useful. ylim y limits plot. See argument xlim. ... arguments passed number_format function.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_flowchart.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a flowchart of the sample size flow in a match_time object — plot_flowchart","text":"FAQ type flowchart function . shown values weird? Multiple numbers resulting flowchart may seem confusing first. First , number potential cases + number potential controls (least first) usually much larger total amount data available. reason individuals get treated \\(t = 0\\) can, theoretically, used control receive treatment. Similarly, sometimes people meet multiple inclusion criteria time, resulting counted respective list reasons inclusion. percentages parenthesis (shown) therefore respect total number potential controls / cases still available time exclusion, total number excluded individuals. Finally, resulting matched dataset (matched cases + matched controls) may larger total input data, even replace_over_t=FALSE replace_at_t=FALSE. , unless replace_cases=FALSE used, individuals used controls may later become cases thus included twice output data. get number distinct individuals resulting data instead, one simply needs call length(unique(data$id)) final matched dataset. make text fit page? Usually, resulting plot look poorly lower right corner interactive R studio session. clicking \"zoom\" button, much better version appear. plot usually way big fit corner. saving file therefore usually makes sense make width height parameters rather large get effect. Users encouraged play around parameters. Additional optimisations can done various arguments relating boxes. Can add boxes? using function publication, might make sense add boxes plot additional information. may done using regular ggplot2 syntax. boxes can created using geom_textbox function ggtext package. Lines arrows drawn simply using geom_segment function. arrows placed poorly? actual width boxes dependent size plot internally boxes lines independent one another, simple way make arrows fit right top boxes naturally. Users can usually create desired effect changing arrow_hjust argument trial error. fails, users may set arrow=FALSE add arrows using geom_segment function.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_flowchart.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a flowchart of the sample size flow in a match_time object — plot_flowchart","text":"Returns standard ggplot2 object can saved ggsave call.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_flowchart.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot a flowchart of the sample size flow in a match_time object — plot_flowchart","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_flowchart.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a flowchart of the sample size flow in a match_time object — plot_flowchart","text":"","code":"library(data.table) library(MatchTime)  set.seed(12341234)  if (requireNamespace(\"survival\") & requireNamespace(\"ggplot2\") &     requireNamespace(\"ggplot2\") & requireNamespace(\"ggtext\")) {  library(ggtext) library(ggplot2) library(survival)  # load heart dataset from survival package data(\"heart\", package=\"survival\")  # add some random variables that will be used as inclusion criteria # (in reality you would already have them) heart$A <- sample(c(TRUE, FALSE), size=nrow(heart), replace=TRUE,                   prob=c(0.9, 0.1)) heart$B <- sample(c(TRUE, FALSE), size=nrow(heart), replace=TRUE,                   prob=c(0.9, 0.1)) heart$C <- sample(c(TRUE, FALSE), size=nrow(heart), replace=TRUE,                   prob=c(0.9, 0.1))  # perform some time-dependent matching with inclusion criteria m_objs <- match_time(transplant ~ surgery, data=heart, id=\"id\",                      match_method=\"fast_exact\", method=\"brsm\",                      replace_over_t=TRUE, ratio=1,                      inclusion=c(\"A\", \"B\", \"C\"))  # plot the flowchart plot_flowchart(m_objs) } #> Loading required namespace: ggtext"},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_timeline.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the time under observation for ids in a match_time object — plot_timeline","title":"Plot the time under observation for ids in a match_time object — plot_timeline","text":"Given match_time object created using match_time function, plot_timeline function displays time observation ids relation event added using add_outcome function. function may used visually explain matching process used censoring method.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_timeline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the time under observation for ids in a match_time object — plot_timeline","text":"","code":"plot_timeline(x, include, id_type=x$id, time_name,               status_name, treat_point=TRUE,               outcome_point=TRUE, next_treat_point=TRUE,               linetype=\"solid\", linewidth=1,               size=3, shape_treat=18, shape_outcome=16,               shape_next_treat=8, xlab=\"Time\",               ylab=\".id_new\", legend.position=\"right\",               gg_theme=ggplot2::theme_bw(), warn=TRUE)"},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_timeline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the time under observation for ids in a match_time object — plot_timeline","text":"x match_time object created using match_time function. include optional numeric vector ids displayed plot. argument specified, timelines .id_new matched data displayed. Even small sample sizes might best option, warning message returned default warn=TRUE. three possible ids x$data used specified using id_type argument. id_type three id variables x$data: x$id (original person identifier), .id_new (id identifying separate rows final matched data) .id_pair (id identifying matched pairs). specifying argument, users can choose ids include argument refers . y-axis always display .id_new id, plot include ids mentioned include type id_type. time_name single character string, specifying name time--event variable added x using add_outcome function. event time used end id specific timeline. status_name single character string, specifying name status time--event variable added x using add_outcome function. treat_point Either TRUE FALSE, specifying whether point added whenever person received treatment inclusion time (essentially marking cases). outcome_point Either TRUE FALSE, specifying whether point added whenever person experiences event. next_treat_point Either TRUE FALSE, specifying whether point added whenever person receives treatment included matching process. linetype single character string specifying linetype displayed lines. linewidth single number specifying width displayed lines. size single number specifying size drawn points (). shape_treat shape point drawn treat_point=TRUE. shape_outcome shape point drawn outcome_point=TRUE. shape_next_treat shape point drawn next_treat_point=TRUE. xlab single character string specifying label x-axis. ylab single character string specifying label y-axis. legend.position single character string specifying position label. gg_theme ggplot2 theme added plot. warn Either TRUE FALSE, specifying whether warning printed include specified.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_timeline.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot the time under observation for ids in a match_time object — plot_timeline","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_timeline.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot the time under observation for ids in a match_time object — plot_timeline","text":"displayed timelines always start \"time-zero\" defined matching process (.treat_time x$data). far lines extend depends argument used calling add_outcome function.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_timeline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the time under observation for ids in a match_time object — plot_timeline","text":"Returns ggplot2 object.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/plot_timeline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the time under observation for ids in a match_time object — plot_timeline","text":"","code":"library(data.table) library(MatchTime)  # only execute if packages are available if (requireNamespace(\"survival\") & requireNamespace(\"ggplot2\") &     requireNamespace(\"MatchIt\")) {  library(survival) library(ggplot2) library(MatchIt)  # set random seed to make the output replicably set.seed(1234)  # load \"heart\" data from survival package data(\"heart\")  # perform nearest neighbor time-dependent matching on \"age\" and \"surgery\" # (plus exact matching on time) out <- match_time(transplant ~ age + surgery, data=heart, id=\"id\",                   match_method=\"nearest\", replace_over_t=TRUE)  # suppose we had an extra dataset with events that looks like this # NOTE: these are not all events in the real \"heart\" data and is merely used #       for showcasing the functionality of add_outcome() d_events <- data.table(id=c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),                        time=c(50, 6, 16, 39, 18, 3, 675, 40, 85, 58))  # add the outcome to the match_time object out <- add_outcome(out, data=d_events, time=\"time\", censor_at_treat=TRUE)  # plot the timeline for the original ids # NOTE: here we see that id = 4 occurs 3 times in the matched dataset #       1.) as a case, starting from ~ t = 36 (.id_new = 89) #       2.) as a control, starting from ~ t = 23 (.id_new = 63) #       3.) as a control, starting from ~ t = 2 (.id_new = 5) #       This is possible because replace_over_t=TRUE was used plot_timeline(out, include=c(1, 2, 3, 4, 5),               time_name=\".event_time\", status_name=\".status\") } #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred"},{"path":"https://robindenz1.github.io/MatchTime/reference/simplify_start_stop.html","id":null,"dir":"Reference","previous_headings":"","what":"Combines rows with the same values in start-stop data — simplify_start_stop","title":"Combines rows with the same values in start-stop data — simplify_start_stop","text":"Given data.table-like object containing information start-stop format, function searches consecutive intervals values specific covariates change \"simplifies\" dataset combining interval one interval. may useful reduce RAM usage computation time dealing large start-stop data.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/simplify_start_stop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combines rows with the same values in start-stop data — simplify_start_stop","text":"","code":"simplify_start_stop(data, id, start=\"start\", stop=\"stop\",                     cols, remove_other_cols=TRUE)"},{"path":"https://robindenz1.github.io/MatchTime/reference/simplify_start_stop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combines rows with the same values in start-stop data — simplify_start_stop","text":"data data.table like object including least four columns: id (case identifier), start (beginning time-interval), stop (end time-interval) one arbitrary columns. May also object can coerced data.table, data.frame tibble. Intervals right-open (e.g. coded [start, stop)). id single character string specifying column data containing case identifiers. start single character string specifying column data specifying beginning time-interval. Defaults \"start\". stop single character string specifying column data specifying ending time-interval. Defaults \"stop\". cols character vector specifying columns used check whether intervals unique. specified, columns id, start stop used. remove_other_cols Either TRUE FALSE, specifying whether columns named cols argument (id, start, stop) removed output. Defaults TRUE, keeping columns may misleading. set FALSE, please remember value columns neccesarily correct, since intervals combined without looking values first.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/simplify_start_stop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combines rows with the same values in start-stop data — simplify_start_stop","text":"intervals defined start stop columns expected coded [start, stop), meaning value start must always equal value stop previous row. Intervals length 0 supported produce error message. Note input data contains events, users probably want exclude event columns cols argument. reason data may contain consecutive intervals indeed exactly , refer two separate events (intervals always end event indicator TRUE).","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/simplify_start_stop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combines rows with the same values in start-stop data — simplify_start_stop","text":"Returns single data.table containing simplified dataset.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/simplify_start_stop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Combines rows with the same values in start-stop data — simplify_start_stop","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/simplify_start_stop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combines rows with the same values in start-stop data — simplify_start_stop","text":"","code":"library(MatchTime) library(data.table)  # get some fake example data data1 <- data.table(id=1,                     start=c(1, 20, 35, 120, 923, 1022, 2000, 3011),                     stop=c(20, 35, 120, 923, 1022, 2000, 3011, 3013),                     A=c(0, 0, 0, 1, 1, 0, 0, 0),                     B=c(1, 0, 0, 1, 0, 0, 0, 0),                     C=c(11, 0.2, 17.8, 2.1, 9.0001, 1.2, 33, 22)) data2 <- data.table(id=2,                     start=c(1, 20, 35, 120, 923),                     stop=c(20, 35, 120, 923, 1022),                     A=c(0, 0, 1, 1, 1),                     B=c(1, 0, 0, 1, 0),                     C=c(11, 0.2, 17.8, 2.1, 9.0001)+1) data <- rbind(data1, data2)  # simplify in regards to columns \"A\" and \"B\" out <- simplify_start_stop(data, id=\"id\", cols=c(\"A\", \"B\")) print(out) #> Key: <id, start> #>        id start  stop     A     B #>     <num> <num> <num> <num> <num> #>  1:     1     1    20     0     1 #>  2:     1    20   120     0     0 #>  3:     1   120   923     1     1 #>  4:     1   923  1022     1     0 #>  5:     1  1022  3013     0     0 #>  6:     2     1    20     0     1 #>  7:     2    20    35     0     0 #>  8:     2    35   120     1     0 #>  9:     2   120   923     1     1 #> 10:     2   923  1022     1     0  # simplify in regards to column \"A\" only out <- simplify_start_stop(data, id=\"id\", cols=\"A\") print(out) #> Key: <id, start> #>       id start  stop     A #>    <num> <num> <num> <num> #> 1:     1     1   120     0 #> 2:     1   120  1022     1 #> 3:     1  1022  3013     0 #> 4:     2     1    35     0 #> 5:     2    35  1022     1  # calling it without specifying \"cols\" results in no changes, # because C always changes over the defined intervals out <- simplify_start_stop(data, id=\"id\") print(out) #> Key: <id, start> #>        id start  stop     A     B       C #>     <num> <num> <num> <num> <num>   <num> #>  1:     1     1    20     0     1 11.0000 #>  2:     1    20    35     0     0  0.2000 #>  3:     1    35   120     0     0 17.8000 #>  4:     1   120   923     1     1  2.1000 #>  5:     1   923  1022     1     0  9.0001 #>  6:     1  1022  2000     0     0  1.2000 #>  7:     1  2000  3011     0     0 33.0000 #>  8:     1  3011  3013     0     0 22.0000 #>  9:     2     1    20     0     1 12.0000 #> 10:     2    20    35     0     0  1.2000 #> 11:     2    35   120     1     0 18.8000 #> 12:     2   120   923     1     1  3.1000 #> 13:     2   923  1022     1     0 10.0001"},{"path":"https://robindenz1.github.io/MatchTime/reference/start_stop2long.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a start-stop dataset into the long-format — start_stop2long","title":"Transform a start-stop dataset into the long-format — start_stop2long","text":"Given data.table like object start-stop format, function returns data.table long-format.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/start_stop2long.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a start-stop dataset into the long-format — start_stop2long","text":"","code":"start_stop2long(data, id, events=NULL, start=\"start\",                 stop=\"stop\", fill_gaps=FALSE,                 include_last_t=FALSE, time_name=\"time\",                 ...)"},{"path":"https://robindenz1.github.io/MatchTime/reference/start_stop2long.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a start-stop dataset into the long-format — start_stop2long","text":"data data.table like object including least three columns: id (unique case identifier), start (beginning time-interval) stop (end time-interval). May also object can coerced data.table, data.frame tibble. Intervals right-open (coded [start, stop)) thus overlapping . May contain number additional columns. id single character string specifying column data specifying unique case identifier. events Either NULL (default) character vector specifying variable names data. columns specified argument logical considered event indicators, meaning coded time-varying variables. Instead coded occurring exactly stop duration . long-format output, columns TRUE time occurrence, interval coded. start single character string specifying column data specifying beginning time-interval. Defaults \"start\". stop single character string specifying column data specifying ending time-interval. Defaults \"stop\". fill_gaps Either TRUE FALSE (default), specifying whether intervals missing data still present output. set TRUE, fill_gaps_start_stop function called input data first. include_last_t Whether include last value stop per id output. Whether done depends intervals coded. time_name single character string, specifying name \"time\" column output. ... arguments passed fill_gaps_start_stop fill_gaps=TRUE, ignored otherwise.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/start_stop2long.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a start-stop dataset into the long-format — start_stop2long","text":"Returns single data.table containing long-format data. start stop columns input replaced single time_name column.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/start_stop2long.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transform a start-stop dataset into the long-format — start_stop2long","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/start_stop2long.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a start-stop dataset into the long-format — start_stop2long","text":"","code":"library(MatchTime) library(data.table)  # define some example start-stop data data <- data.table(id=c(1, 1, 1, 2, 2, 3),                    start=c(0, 14, 26, 0, 18, 0),                    stop=c(14, 26, 30, 18, 32, 51),                    A=c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6),                    B=c(1L, 1L, 2L, 3L, 5L, 6L),                    C=c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE),                    D=c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"))  # transform to long-format out <- start_stop2long(data, id=\"id\") head(out) #> Key: <id, time> #>       id     A     B      C      D  time #>    <num> <num> <int> <lgcl> <char> <int> #> 1:     1   0.1     1   TRUE      A     0 #> 2:     1   0.1     1   TRUE      A     1 #> 3:     1   0.1     1   TRUE      A     2 #> 4:     1   0.1     1   TRUE      A     3 #> 5:     1   0.1     1   TRUE      A     4 #> 6:     1   0.1     1   TRUE      A     5  # if C was coded as an event instead, we would want to use: out <- start_stop2long(data, id=\"id\", events=\"C\") head(out) #> Key: <id, time> #>       id  time     A     B      D      C #>    <num> <int> <num> <int> <char> <lgcl> #> 1:     1     0   0.1     1      A  FALSE #> 2:     1     1   0.1     1      A  FALSE #> 3:     1     2   0.1     1      A  FALSE #> 4:     1     3   0.1     1      A  FALSE #> 5:     1     4   0.1     1      A  FALSE #> 6:     1     5   0.1     1      A  FALSE"},{"path":"https://robindenz1.github.io/MatchTime/reference/stratified_sample.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast Stratified Sampling from a data.table like object — stratified_sample","title":"Fast Stratified Sampling from a data.table like object — stratified_sample","text":"function may used draw stratified random sample (without replacement) rows data.table similar object. additionally includes options handle cases number drawn less number actual rows using replace=FALSE, makes useful exact matching.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/stratified_sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast Stratified Sampling from a data.table like object — stratified_sample","text":"","code":"stratified_sample(data, n, strata, replace=FALSE,                   max_replace=NULL, if_lt_n=\"stop\")"},{"path":"https://robindenz1.github.io/MatchTime/reference/stratified_sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast Stratified Sampling from a data.table like object — stratified_sample","text":"data data.table like object sampled . May also object can coerced data.table, data.frame tibble. n named numeric vector containing values > 0, specifying number rows sampled value strata. strata single character string specifying integer, character factor variable representing strata sampled data. supports single variable. data sampled strata multiple variables, user needs first create single variable multiple variables shown examples. replace Either TRUE FALSE (default). Specifies whether sampling performed without replacement. max_replace Either NULL (default) named numeric vector containing values > 0, specifying number times rows value strata may replace using replace=TRUE. Ignored replace=FALSE. Keeping argument NULL results upper limit replacement rows per strata. if_lt_n Must either \"stop\", \"warn\" \"nothing\". Controls whether throw error, warning silently accept number rows stratum specified strata smaller number sampled replace=FALSE used.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/stratified_sample.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fast Stratified Sampling from a data.table like object — stratified_sample","text":"Internally splits data.table parts defined strata variable uses sample.int function sample rows strata. using data.table functions sample.int instead sample, function efficient even large data.tables many possible strata.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/stratified_sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast Stratified Sampling from a data.table like object — stratified_sample","text":"Returns single data.table containing sampled rows.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/stratified_sample.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fast Stratified Sampling from a data.table like object — stratified_sample","text":"Lohr, Sharon L. (2010). Sampling: Design Analysis. Bd. 2. Boston: Cengage Learning.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/stratified_sample.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fast Stratified Sampling from a data.table like object — stratified_sample","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/stratified_sample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast Stratified Sampling from a data.table like object — stratified_sample","text":"","code":"library(MatchTime) library(data.table) library(fastmatch)  set.seed(344)  data <- data.table(A=stats::rnorm(n=100),                    B=sample(c(\"A\", \"B\", \"C\"), size=100, replace=TRUE),                    strat=sample(c(\"1\", \"2\", \"3\"), size=100, replace=TRUE))  n <- c(10, 25, 31) names(n) <- c(\"2\", \"1\", \"3\")  # sample (without replacement): # - 25 rows from strat==\"1\" # - 10 rows from strat==\"2\" # - 31 rows from strat==\"3\" samp <- stratified_sample(data, n=n, strata=\"strat\")  # take the same stratified sample with replacement samp <- stratified_sample(data, n=n, strata=\"strat\", replace=TRUE)"},{"path":"https://robindenz1.github.io/MatchTime/reference/subset_start_stop.html","id":null,"dir":"Reference","previous_headings":"","what":"Subsetting start-stop format datasets — subset_start_stop","title":"Subsetting start-stop format datasets — subset_start_stop","text":"Returns subsets data.table like object start-stop format. Contrary usual subset function, function subsets (truncates) specific time-intervals use logical expression subset data based column values. May useful limit start-stop based datasets certain time-range.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/subset_start_stop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subsetting start-stop format datasets — subset_start_stop","text":"","code":"subset_start_stop(data, first_time, last_time,                   truncate=TRUE, start=\"start\",                   stop=\"stop\", na.rm=FALSE)"},{"path":"https://robindenz1.github.io/MatchTime/reference/subset_start_stop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subsetting start-stop format datasets — subset_start_stop","text":"data data.table like object including least two columns: start (beginning time-interval) stop (end time-interval). May also object can coerced data.table, data.frame tibble. Intervals coded [start, stop), like functions package. first_time single value vector size nrow(data) class numeric, Date something similar, specifying first time kept output. intervals ending value removed. Additionally, truncate=TRUE, intervals starting first_time ending first_time truncated start first_time. last_time single value vector size nrow(data) class numeric, Date something similar, specifying last time kept output. intervals beginning value removed. Additionally, truncate=TRUE, intervals starting last_time ending last_time truncated end last_time. truncate Either TRUE FALSE, controls whether existing intervals truncated first_time last_time. See respective arguments info. start single character string specifying column data specifying beginning time-interval. Defaults \"start\". stop single character string specifying column data specifying ending time-interval. Defaults \"stop\". na.rm Either TRUE FALSE (default), controls whether remove rows either first_time last_time NA.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/subset_start_stop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subsetting start-stop format datasets — subset_start_stop","text":"Returns single data.table containing subsetted start-stop data.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/subset_start_stop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Subsetting start-stop format datasets — subset_start_stop","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/subset_start_stop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subsetting start-stop format datasets — subset_start_stop","text":"","code":"library(MatchTime) library(data.table)  # define some example start-stop data data <- data.table(id=c(1, 1, 1, 1, 1, 2, 2, 2),                    start=c(0, 10, 25, 812, 1092, 90, 9023, 10000),                    stop=c(10, 25, 812, 1092, 34334, 8021, 9823, 220022),                    some_col=c(1, 2, 3, 4, 5, 6, 7, 8))  # limit it to the time-range 28 - 1900 out <- subset_start_stop(data, first_time=28, last_time=1900) print(out) #>       id start  stop some_col #>    <num> <num> <num>    <num> #> 1:     1    28   812        3 #> 2:     1   812  1092        4 #> 3:     1  1092  1900        5 #> 4:     2    90  1900        6  # don't truncate intervals out <- subset_start_stop(data, first_time=28, last_time=1900,                          truncate=FALSE) print(out) #>       id start  stop some_col #>    <num> <num> <num>    <num> #> 1:     1    25   812        3 #> 2:     1   812  1092        4 #> 3:     1  1092 34334        5 #> 4:     2    90  8021        6  # only cut-off intervals before t = 28 out <- subset_start_stop(data, first_time=28) print(out) #>       id start   stop some_col #>    <num> <num>  <num>    <num> #> 1:     1    28    812        3 #> 2:     1   812   1092        4 #> 3:     1  1092  34334        5 #> 4:     2    90   8021        6 #> 5:     2  9023   9823        7 #> 6:     2 10000 220022        8  # only cut-off intervals after t = 28 out <- subset_start_stop(data, last_time=28) print(out) #>       id start  stop some_col #>    <num> <num> <num>    <num> #> 1:     1     0    10        1 #> 2:     1    10    25        2 #> 3:     1    25    28        3  # using different cut-off values for each person # note that we have to repeat the respective cut-off values as many times # as each id appears to make this work out <- subset_start_stop(data, last_time=c(rep(723, 5), rep(815, 3))) print(out) #>       id start  stop some_col #>    <num> <num> <num>    <num> #> 1:     1     0    10        1 #> 2:     1    10    25        2 #> 3:     1    25   723        3 #> 4:     2    90   815        6"},{"path":"https://robindenz1.github.io/MatchTime/reference/summary.match_time.html","id":null,"dir":"Reference","previous_headings":"","what":"View a balance summary of a match_time object — summary.match_time","title":"View a balance summary of a match_time object — summary.match_time","text":"Computes prints balance statistics match_time objects baseline, similar summary method matchit objects. Similar functionality implemented bal.tab.match_time.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/summary.match_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"View a balance summary of a match_time object — summary.match_time","text":"","code":"# S3 method for class 'match_time' summary(object, standardize=TRUE,         remove_unmatched=TRUE,         n_required=object$info$ratio, ...)"},{"path":"https://robindenz1.github.io/MatchTime/reference/summary.match_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"View a balance summary of a match_time object — summary.match_time","text":"object match_time object created using match_time function. standardize Either TRUE FALSE; whether compute standardized (TRUE) unstandardized (FALSE) statistics. standardized statistics standardized mean difference mean maximum difference (weighted) empirical cumulative distribution functions (ECDFs). unstandardized statistics raw mean difference mean maximum quantile-quantile (QQ) difference. Variance ratios produced either way. See Details . Default TRUE. remove_unmatched Whether remove unmatched individuals calculating balance statistics. Internally, match_data function called , please see documentation function information. influence computed sample sizes. n_required argument name match_data. ... Currently used.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/summary.match_time.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"View a balance summary of a match_time object — summary.match_time","text":"Robin Denz","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/summary.match_time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"View a balance summary of a match_time object — summary.match_time","text":"Balance Statistics: summary method match_time objects made resemble summary method matchit objects. fact directly uses code MatchIt package compute balance statistics. details balance statistics calculated mean, please consult associated documentation page summary.matchit. Note contrary standard matching, matching performed match_time time-dependent. , presenting balance statistics unmatched data impossible. function therefore prints balance statistics baseline (e.g. time cases included matching process). Sample Sizes: displayed sample sizes may confusing without explanation. matching process based dynamically changing risk sets, individual may either \"control\" \"treated\" different points time, easy summarise sample sizes terms binary distinction \"Controls\" \"Treated\". Displayed \"Matched\" numbers individuals form fully matched pairs output (e.g. case received ratio matched controls). \"Unmatched Controls\" refer potential controls never used matching process, \"Unmatched Treated\" refers cases receive ratio matched controls. Note individuals mentioned \"Unmatched Treated\" may still used controls matching process. \"\" column simply sum \"Controls\" \"Treated\" \"Matched\" \"Unmatched\" individuals. \"Included Controls\" refers individuals fufilled inclusion criteria point time becoming \"treated\", \"Included Treated\" refers individuals fufilled inclusion criteria point time received treatment. \"Supplied Controls\" similarly refers number individuals , applying inclusion criteria, present \"untreated\" point time data supplied match_time. \"Supplied Treated\" number individuals , applying inclusion criteria, present \"treated\" point time data. \"\" column usually sum \"Controls\" \"Treated\" , unless treatment occured exactly t = 0, cases may used controls well. total numbers, calculated irrespective replacement options used. detailed information number cases, number matched controls number potential controls evolved time matching process, plot.match_time function may used. Alternatively, users may directly inspect trace object included output object match_time.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/summary.match_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"View a balance summary of a match_time object — summary.match_time","text":"Silently returns list containing balance statistics sample sizes.","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/summary.match_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"View a balance summary of a match_time object — summary.match_time","text":"","code":"library(data.table) library(MatchTime)  # only execute if packages are available if (requireNamespace(\"MatchIt\") & requireNamespace(\"survival\")) {  library(MatchIt) library(survival)  # set random seed to make the output replicably set.seed(1234)  # load \"heart\" data from survival package data(\"heart\")  # perform nearest neighbor time-dependent matching on \"age\" and \"surgery\" # (plus exact matching on time) out <- match_time(transplant ~ age + surgery, data=heart, id=\"id\",                   match_method=\"nearest\") summary(out) } #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred #> Call: #> match_time(formula = transplant ~ age + surgery, data = heart,  #>     id = \"id\", match_method = \"nearest\") #>  #> Summary of Balance for Matched Data at Baseline: #>         Means Treated Means Control Std. Mean Diff. Var. Ratio  eCDF Mean #> event       0.4745763     0.4883721              NA         NA 0.01379582 #> age        -2.5997517    -2.6059883              NA         NA 0.04105950 #> year        3.5534519     3.3669198              NA         NA 0.03444160 #> surgery     0.1864407     0.1162791              NA         NA 0.07016161 #>           eCDF Max #> event   0.01379582 #> age     0.12105712 #> year    0.07416880 #> surgery 0.07016161 #>  #> Sample Sizes: #>           Controls Treated All #> Matched         51      51 102 #> Unmatched       17      18  35 #> Included       103      69 103 #> Supplied       103      69 103 #>  #> Points in Time: #> Matching was performed at 43 unique points in time between 1 and 310."},{"path":"https://robindenz1.github.io/MatchTime/reference/times_from_start_stop.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract ","title":"Extract ","text":"Given data.table like object start-stop format, returns new data.table containing times events particular type happened.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/times_from_start_stop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract ","text":"","code":"times_from_start_stop(data, id, name, type, start=\"start\",                       stop=\"stop\", time_name=\"time\")"},{"path":"https://robindenz1.github.io/MatchTime/reference/times_from_start_stop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract ","text":"data data.table like object including least three columns: id (unique case identifier), start (beginning time-interval) stop (end time-interval). May also object can coerced data.table, data.frame tibble. Intervals coded [start, stop), like functions package. id single character string specifying column containing unique case identifier. name single character string specifying \"event\" column data. specified column class \"logical\" (containing either TRUE FALSE). Alternatively, specified variable may numeric variable containing 0 (considered FALSE) 1 (considered TRUE). type single character string specifying type variable column specified name . variable actual event, meaning existing intervals end exact time name occured, set type=\"event\". case, stop value intervals name TRUE extracted. variable refers time-varying binary variable instead (example time-dependent exposure can present absent), set \"var\", case start time duration name TRUE extracted. See details. start single character string specifying column data specifying beginning time-interval. Defaults \"start\". stop single character string specifying column data specifying ending time-interval. Defaults \"stop\". time_name single character string specifying name \"time\" variable output data. Defaults \"time\".","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/times_from_start_stop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract ","text":"Returns single data.table containing subsetted start-stop data.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/times_from_start_stop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract ","text":"function may useful extract times occurence binary time-dependent exposures actual events start-stop data. Use Time-Varying Variables: type=\"var\" used variable specified name treated simple time-varying variable start times uninterrupted duration variable TRUE extracted. example, variable starts TRUE t = 20 stops TRUE t = 123 never TRUE times, time_name simple 20 individual, regardless many intervals present name TRUE. done continuously TRUE want extract initial time \"occured\" \"happened\". case, name goes back FALSE TRUE later, example t = 700, output contain another entry id including time 700, constitutes another occurence. Use actual events: type=\"event\" used instead, every single occurence TRUE input data considered specify single event occurence name, regardless whether intervals directly one another. classic difference coding time-varying variables events start-stop data, discussed survival package documentation vignettes package.","code":""},{"path":"https://robindenz1.github.io/MatchTime/reference/times_from_start_stop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract ","text":"Robin Denz","code":""},{"path":[]},{"path":"https://robindenz1.github.io/MatchTime/reference/times_from_start_stop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract ","text":"","code":"library(MatchTime) library(data.table)  # define some example start-stop data data <- data.table(id=c(1, 1, 1, 1, 1, 2, 2, 2),                    start=c(0, 10, 25, 812, 1092, 90, 9023, 10000),                    stop=c(10, 25, 812, 1092, 34334, 8021, 9823, 220022),                    exposure=c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE,                               TRUE))  # treating it as an exposure # NOTE: in this case, the first two rows of id = 1 are considered to be #       one continuous occurence, because \"exposure\" stayed TRUE the entire #       time out1 <- times_from_start_stop(data, id=\"id\", name=\"exposure\", type=\"var\") head(out1) #> Key: <id, time> #>       id  time #>    <num> <num> #> 1:     1     0 #> 2:     1   812 #> 3:     2 10000  # treating it as an event # NOTE: in this case the first two rows of id = 1 are considered to be #       two independent events, events force a time-interval to stop out2 <- times_from_start_stop(data, id=\"id\", name=\"exposure\", type=\"event\") head(out2) #> Key: <id, time> #>       id   time #>    <num>  <num> #> 1:     1     10 #> 2:     1     25 #> 3:     1   1092 #> 4:     2 220022"}]
