---
title: "Simulation mit Hazard Ratios"
author: "Robin Denz"
date: "2024-09-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE)

library(simDAG)
library(survival)
library(foreach)
library(parallel)
library(doSNOW)
library(doRNG)
library(ggplot2)
library(fastmatch)
library(data.table)
library(dplyr)
library(devtools)
library(adjustedCurves)

load_all()
```

# Vorbemerkungen

Ziel der Simulationen in diesem Dokument ist die Auswertungsmethodik besser zu verstehen und die von mir programmierte Implementierung dieser zu validieren. Es werden keine realistischen Werte verwendet, sondern lediglich irgendwelche Werte mit denen man die erwarteten Effekt beobachten kann.

Es werden zunächst 3 Simulationszenarien betrachtet, in denen es kein treatment-confounder feedback über die Zeit gibt. In diesen Fällen sollten die Ergebnisse aus einem einfachen Cox Modell mit zeitabhängigen Kovariaten mit denen des zeitabhängigen Matchings übereinstimmen. Dies wird überprüft bei:

* (1) Simulation ohne Confounding
* (2) Simulation mit zeit-konstantem Confounder
* (3) Simulation mit zeitabhängigem Confounder

Erst danach werden Simulationen mit treatment-confounder feedback durchgeführt. Dabei ist dann nicht mehr zu erwarten das die HRs aus den Cox Modellen gleich sind. Dies soll überprüft werden.

```{r}
## compare standard cox with time-dependent matching
sim_comp <- function(dag, n_sim, n_repeats, max_t, n_cores, seed=runif(1),
                     formula_cox, formula_matching, td_variables=NULL,
                     baseline_covars=c("mac"), progressbar=TRUE, ...) {

  # parallel processing
  cl <- makeCluster(n_cores, outfile="")
  doSNOW::registerDoSNOW(cl)
  pckgs <- c("data.table", "simDAG", "survival", "MatchTD", "adjustedCurves")
  glob_funs <- ls(envir=.GlobalEnv)[sapply(ls(envir=.GlobalEnv), function(obj)
    "function"==class(eval(parse(text=obj)))[1])]

  # add progress bar
  if (progressbar) {
    pb <- utils::txtProgressBar(max=n_repeats, style=3)
    progress <- function(n) {utils::setTxtProgressBar(pb, n)}
    opts <- list(progress=progress)
  } else {
    opts <- NULL
  }
  
  if (n_cores==1) {
    `%dofun%` <- `%do%`
  } else {
    `%dofun%` <- `%dorng%`
  }
  
  # start simulation
  set.seed(seed)
  out_final <- foreach::foreach(i=seq_len(n_repeats), .packages=pckgs,
                          .export=glob_funs, .options.snow=opts) %dofun% {

    # generate the data
    sim <- sim_discrete_time(dag, n_sim=n_sim, max_t=max_t)

    #### standard time-varying cox model based estimates ####
    data <- sim2data(sim, to="start_stop", target_event="influenza",
                     overlap=TRUE, keep_only_first=TRUE)

    form <- stats::as.formula(formula_cox)
    mod <- coxph(form, data=data)

    out_1 <- as.data.frame(summary(mod)$conf.int)
    out_1$name <- rownames(out_1)
    rownames(out_1) <- NULL
    out_1$type <- "cox"

    #### time-dependent matching based estimates ####
    
    # extract required data
    d_treat <- get_event_times(sim, "vacc")
    d_influ <- get_event_times(sim, "influenza")
    d_baseline <- sim$data[, c(".id", baseline_covars), with=FALSE]
    
    # add information about time-dependent covariates
    if (length(td_variables) > 0) {
      
      td_names <- vapply(td_variables, FUN=function(x){x$name},
                         FUN.VALUE=character(1))
      durations <- vapply(td_variables, FUN=function(x){x$duration},
                         FUN.VALUE=numeric(1))
      
      # create dlist
      dlist <- lapply(td_names, FUN=function(x, sim){
        get_event_times(sim=sim, name=x)}, sim=sim)
      names(dlist) <- td_names
      
      # create start-stop data
      d_covars <- MatchTD:::list2start_stop(dlist,
                                            n=nrow(d_baseline),
                                            max_t=max_t,
                                            durations=durations)
      # merge with baseline info
      d_covars <- merge(d_covars, d_baseline, by=".id", all.x=TRUE)
      
    } else {
      d_covars <- d_baseline
      d_covars[, start := 1]
      d_covars[, stop := max_t]
    }

    # construct inclusion criteria start-stop
    dlist <- list(d_influ)
    names(dlist) <- c("influenza")
    d_inclusion <- MatchTD:::list2start_stop(dlist, n=nrow(d_baseline),
                                             max_t=max_t, durations=20)
    d_inclusion <- d_inclusion[influenza==FALSE]

    # perform the matching
    d_match <- match_td(id=".id", time=".time", d_treat=d_treat,
                        d_event=d_influ, d_covars=d_covars,
                        keep_all_column=TRUE, d_inclusion=d_inclusion, ...)

    # fit cox model
    form <- stats::as.formula(formula_matching)
    mod <- coxph(formula=form, data=d_match)

    # put together
    out_2 <- as.data.frame(summary(mod)$conf.int)
    out_2$name <- rownames(out_2)
    rownames(out_2) <- NULL
    out_2$type <- "matching"

    rbind(out_1, out_2)
  }
  close(pb)
  stopCluster(cl)

  return(rbindlist(out_final))
}

## extract all unique event times from a simDT object
get_event_times <- function(sim, name) {

  ldat <- sim$tte_past_events[[name]]
  out <- vector(mode="list", length=length(ldat))
  for (i in seq_len(length(ldat))) {
    if (length(ldat[[i]]) > 0) {
      out[[i]] <- data.table(.id=ldat[[i]], .time=i)
    }
  }
  d_prev <- rbindlist(out)
  setkeyv(d_prev, c(".id", ".time"))

  return(d_prev)
}

## plot bias of HRs
plot_bias <- function(out, true_rr) {

  out$name[out$name==".treatTRUE"] <- "vacc"
  out$name[out$name=="macTRUE"] <- "mac"
  out$name[out$name=="vaccTRUE"] <- "vacc"
  out$name[out$name=="macTRUE:.treatTRUE"] <- "mac*vacc"
  out$name[out$name=="macTRUE:vaccTRUE"] <- "mac*vacc"
  out$name[out$name=="medsTRUE"] <- "meds"
  out$name[out$name=="sexTRUE"] <- "sex"

  true_rr <- data.table(name=names(true_rr),
                        rr=true_rr)
  out <- merge(out, true_rr, by="name", all.x=TRUE)
  out[, bias := `exp(coef)` - rr]

  # bias
  ggplot(out, aes(x=name, y=bias, fill=name)) +
    geom_boxplot() +
    facet_wrap(~type) +
    theme_bw() +
    theme(legend.position="none") +
    geom_hline(yintercept=0, linetype="dashed")
}
```

# Kein Confounding

Im ersten Schritt werden nur Daten zu MAC, Impfung und Influenza simuliert, ohne jede Form von Confounding.

```{r, echo=TRUE}
prob_influ <- function(data, base_p, rr_mac, rr_vacc_mac, rr_vacc_nonmac) {
  base_p * rr_mac^(data$mac) * rr_vacc_mac^(data$mac & data$vacc_event) *
    rr_vacc_nonmac^(data$vacc_event & !data$mac)
}

dag <- empty_dag() +
  node("mac", type="rbernoulli", p=0.2) +
  node_td("vacc", type="time_to_event", prob_fun=0.001,
          event_duration=Inf) +
  node_td("influenza", type="time_to_event", prob_fun=prob_influ,
          event_duration=20, parents=c("mac", "vacc_event"),
          base_p=0.01, rr_mac=1.5, rr_vacc_mac=0.8, rr_vacc_nonmac=0.5)

plot(dag)
```

```{r}
set.seed(32457)
sim <- sim_discrete_time(dag, n_sim=100000, max_t=365)
```

## Beispiel Cox Modell

```{r}
dmod <- sim2data(sim, to="start_stop", target_event="influenza",
                 overlap=TRUE, keep_only_first=TRUE)

mod <- coxph(Surv(start, stop, influenza) ~ mac + vacc + mac*vacc, data=dmod)
summary(mod)
```

## Beispiel Matching

```{r}
d_treat <- get_event_times(sim, "vacc")
d_event <- get_event_times(sim, "influenza")
d_baseline <- sim$data[, c(".id", "mac"), with=FALSE]
d_baseline[, start := 1]
d_baseline[, stop := 365]

dlist <- list(d_event)
names(dlist) <- c("influenza")
d_inclusion <- MatchTD:::list2start_stop(dlist, n=nrow(d_baseline),
                                         max_t=365, durations=20)
d_inclusion <- d_inclusion[influenza==FALSE]

d_match <- match_td(id=".id", time=".time", d_treat=d_treat,
                    d_covars=d_baseline, d_event=d_event,
                    d_inclusion=d_inclusion, verbose=FALSE)

mod <- coxph(Surv(event_time, status) ~ mac + .treat + mac*.treat, data=d_match)
summary(mod)
```

## Monte-Carlo Vergleich

```{r}
set.seed(1344145)

out <- sim_comp(
  dag=dag,
  n_sim=4000,
  n_repeats=500,
  max_t=365,
  n_cores=8,
  if_lt_n_at_t="warn",
  formula_cox="Surv(start, stop, influenza) ~ mac + vacc + mac*vacc",
  formula_matching="Surv(event_time, status) ~ mac + .treat + mac*.treat",
  progressbar=FALSE
)

true_rr <- c("mac"=1.5, "vacc"=0.5, "mac*vacc"=1.6)
plot_bias(out, true_rr)
```

# Time-Fixed Confounder

Hier wird die obige Simulation erweitert, indem ein zeitunabhängiger Confounder (Sex) hnzugefügt wird. Dieser hat einen direkten kausalen Einfluss auf die Impfwahrscheinlichkeit und auf die Wahrscheinlichkeit Influenza zu bekommen.

```{r, echo=TRUE}
prob_influ <- function(data, base_p, rr_mac, rr_vacc_mac, rr_vacc_nonmac,
                       rr_sex) {
  base_p * rr_mac^(data$mac) * rr_vacc_mac^(data$mac & data$vacc_event) *
    rr_vacc_nonmac^(data$vacc_event & !data$mac) * rr_sex^(data$sex)
}

prob_vacc <- function(data, base_p, rr_sex) {
  base_p * rr_sex^(data$sex)
}

dag <- empty_dag() +
  node("mac", type="rbernoulli", p=0.2) +
  node("sex", type="rbernoulli", p=0.5) +
  node_td("vacc", type="time_to_event", prob_fun=prob_vacc,
          event_duration=Inf, parents="sex", base_p=0.0005,
          rr_sex=5) +
  node_td("influenza", type="time_to_event", prob_fun=prob_influ,
          event_duration=20, parents=c("mac", "vacc_event", "sex"),
          base_p=0.001, rr_mac=1.5, rr_vacc_mac=0.8, rr_vacc_nonmac=0.5,
          rr_sex=4)
plot(dag)
```

```{r}
set.seed(324574)
sim <- sim_discrete_time(dag, n_sim=100000, max_t=365)
```

## Cox Beispiel (ohne Adjustierung)

```{r}
dmod <- sim2data(sim, to="start_stop", target_event="influenza",
                 overlap=TRUE, keep_only_first=TRUE)

mod <- coxph(Surv(start, stop, influenza) ~ mac + vacc + mac*vacc, data=dmod)
summary(mod)
```

## Cox Beispiel (mit Adjustierung)

```{r}
mod <- coxph(Surv(start, stop, influenza) ~ mac + vacc + mac*vacc + sex,
             data=dmod)
summary(mod)
```

## Matching Beispiel

```{r}
d_treat <- get_event_times(sim, "vacc")
d_event <- get_event_times(sim, "influenza")
d_baseline <- sim$data[, c(".id", "mac", "sex"), with=FALSE]
d_baseline[, start := 1]
d_baseline[, stop := 365]

dlist <- list(d_event)
names(dlist) <- c("influenza")
d_inclusion <- MatchTD:::list2start_stop(dlist, n=nrow(d_baseline),
                                         max_t=365, durations=20)
d_inclusion <- d_inclusion[influenza==FALSE]

d_match <- match_td(id=".id", time=".time", d_treat=d_treat,
                    d_covars=d_baseline, d_event=d_event,
                    d_inclusion=d_inclusion, verbose=FALSE)

mod <- coxph(Surv(event_time, status) ~ mac + .treat + mac*.treat + sex,
             data=d_match)
summary(mod)
```

## Monte-Carlo Vergleich

```{r}
set.seed(13441454)

out <- sim_comp(
  dag=dag,
  n_sim=4000,
  n_repeats=100,
  max_t=365,
  n_cores=8,
  if_lt_n_at_t="warn",
  formula_cox="Surv(start, stop, influenza) ~ mac + vacc + mac*vacc + sex",
  formula_matching="Surv(event_time, status) ~ mac + .treat + mac*.treat + sex",
  baseline_covars=c("mac", "sex"),
  progressbar=FALSE
)

true_rr <- c("mac"=1.5, "vacc"=0.5, "mac*vacc"=1.6, "sex"=4)
plot_bias(out, true_rr)
```

# Time-Varying Confounder

Hier wird statt einem zeitunabhängigem Confounder ein zeitabhängiger Confounder mit simuliert. Auch dieser erhöht sowohl die Wahrscheinlichkeit geimpft zu werden, als auch die Wahrscheinlichkeit eine Influenza zu bekommen.

```{r, echo=TRUE}
prob_influ <- function(data, base_p, rr_mac, rr_vacc_mac, rr_vacc_nonmac,
                       rr_meds) {
  base_p * rr_mac^(data$mac) * rr_vacc_mac^(data$mac & data$vacc_event) *
    rr_vacc_nonmac^(data$vacc_event & !data$mac) * rr_meds^(data$meds_event)
}

prob_vacc <- function(data, base_p, rr_meds) {
  base_p * rr_meds^(data$meds_event)
}

dag <- empty_dag() +
  node("mac", type="rbernoulli", p=0.2) +
  node_td("meds", type="time_to_event", prob_fun=0.001, event_duration=Inf) +
  node_td("vacc", type="time_to_event", prob_fun=prob_vacc,
          event_duration=Inf, parents="meds_event", base_p=0.0005,
          rr_meds=5) +
  node_td("influenza", type="time_to_event", prob_fun=prob_influ,
          event_duration=20, parents=c("mac", "vacc_event", "meds_event"),
          base_p=0.001, rr_mac=1.5, rr_vacc_mac=0.8, rr_vacc_nonmac=0.5,
          rr_meds=4)
plot(dag)
```

```{r}
set.seed(3245767)
sim <- sim_discrete_time(dag, n_sim=100000, max_t=365)
```

## Cox Beispiel (ohne Adjustierung)

```{r}
dmod <- sim2data(sim, to="start_stop", target_event="influenza",
                 overlap=TRUE, keep_only_first=TRUE)

mod <- coxph(Surv(start, stop, influenza) ~ mac + vacc + mac*vacc, data=dmod)
summary(mod)
```

## Cox Beispiel (mit Adjustierung)

```{r}
mod <- coxph(Surv(start, stop, influenza) ~ mac + vacc + mac*vacc + meds,
             data=dmod)
summary(mod)
```

## Matching Beispiel (ohne Adjustierung)

```{r}
d_treat <- get_event_times(sim, "vacc")
d_influ <- get_event_times(sim, "influenza")
d_meds <- get_event_times(sim, "meds")
d_baseline <- sim$data[, c(".id", "mac"), with=FALSE]
d_baseline[, start := 1]
d_baseline[, stop := 365]

dlist <- list(d_influ)
names(dlist) <- c("influenza")
d_inclusion <- list2start_stop(dlist, n=nrow(d_baseline), max_t=365,
                               durations=20)
d_inclusion <- d_inclusion[influenza==FALSE]

d_match <- match_td(id=".id", time=".time", d_treat=d_treat,
                    d_event=d_influ, d_covars=d_baseline,
                    keep_all_columns=TRUE, d_inclusion=d_inclusion,
                    replace_at_t=FALSE, verbose=FALSE)

mod <- coxph(Surv(event_time, status) ~ .treat + mac + .treat*mac,
             data=d_match)
summary(mod)
```

## Matching Beispiel (mit Adjustierung, ohne Matching für meds)

```{r}
d_match <- add_previous_event_time(data=d_match, id=".id", time=".time",
                                   d_prev=d_meds, duration=Inf, name="meds")

mod <- coxph(Surv(event_time, status) ~ .treat + mac + .treat*mac + meds,
             data=d_match)
summary(mod)
```

## Matching Beispiel (mit Adjustierung, mit Matching für meds)

```{r}
d_treat <- get_event_times(sim, "vacc")
d_influ <- get_event_times(sim, "influenza")
d_meds <- get_event_times(sim, "meds")
d_baseline <- sim$data[, c(".id", "mac"), with=FALSE]

# get d_covars
dlist <- list(d_meds)
names(dlist) <- c("meds")
d_covars <- list2start_stop(dlist, n=nrow(d_baseline), max_t=365,
                            durations=Inf)
d_covars <- merge(d_covars, d_baseline, by=".id", all.x=TRUE)

# get d_inclusion
dlist <- list(d_influ)
names(dlist) <- c("influenza")
d_inclusion <- list2start_stop(dlist, n=nrow(d_baseline), max_t=365,
                               durations=20)
d_inclusion <- d_inclusion[influenza==FALSE]

d_match <- match_td(id=".id", time=".time", d_treat=d_treat,
                    d_event=d_influ, d_covars=d_covars,
                    keep_all_columns=TRUE, d_inclusion=d_inclusion,
                    replace_at_t=FALSE, verbose=FALSE)

mod <- coxph(Surv(event_time, status) ~ .treat + mac + .treat*mac,
             data=d_match)
summary(mod)
```

## Monte-Carlo Vergleich

```{r}
set.seed(24324554)

out <- sim_comp(
  dag=dag,
  n_sim=4000,
  n_repeats=300,
  max_t=365,
  n_cores=8,
  if_lt_n_at_t="warn",
  formula_cox="Surv(start, stop, influenza) ~ mac + vacc + mac*vacc + meds",
  formula_matching="Surv(event_time, status) ~ mac + .treat + mac*.treat + meds",
  td_variables=list(list(name="meds", duration=Inf)),
  progressbar=FALSE
)

true_rr <- c("mac"=1.5, "vacc"=0.5, "mac*vacc"=1.6, "meds"=4)
plot_bias(out, true_rr)
```

Was hier auffällt ist, dass das HR des zeitabhängigen Confounders beim Matching unterschätzt wird. Das liegt daran, dass dieser nur als zeitunabhängige Variable mit ins Modell geht. Sprich, wenn eine Person zum Studieneinschluss noch FALSE bei dieser Variable hatte, aber zu einem späteren Zeitpunkt TRUE hat, wird dies nicht berücksichtigt. Damit gehen einige Zeiträume mit erhöhtem Risiko durch "meds" als Zeiträume unter nicht-"meds" in das Modell ein. Das hat (wie in der Simulation zu sehen ist) aber keinen Einfluss auf die korrekte Schätzung der relevanten HRs. Das Confounding wird korrekt weg-adjustiert, wie erwartet. Nur der Effekt der "meds" selbst ist verzerrt.

# Treatment-Confounder Feedback

Wenn treatment-confounder feedback existiert und man schlicht ein einfaches Cox Modell mit start-stop Daten verwendet, wird ein teil des totalen kausalen Effekts weg-adjustiert: nämlich der indirekte Effekt der über die Variable geht welche sowohl Confounder als auch Mediator ist. Dieses Problem sollte beim zeitabhängigen Matching nicht vorliegen. Demnach müssten sich die HRs der beiden Methoden unterscheiden. Dies wird zunächst hier überprüft.

```{r, echo=TRUE}
prob_influ <- function(data, base_p, rr_mac, rr_vacc_mac, rr_vacc_nonmac,
                       rr_meds) {
  base_p * rr_mac^(data$mac) * rr_vacc_mac^(data$mac & data$vacc_event) *
    rr_vacc_nonmac^(data$vacc_event & !data$mac) * rr_meds^(data$meds_event)
}

prob_vacc <- function(data, base_p, rr_meds) {
  base_p * rr_meds^(data$meds_event)
}

prob_meds <- function(data, base_p, rr_vacc) {
  base_p * rr_vacc^(data$vacc_event)
}

dag <- empty_dag() +
  node("mac", type="rbernoulli", p=0.2) +
  node_td("meds", type="time_to_event", prob_fun=prob_meds,
          event_duration=Inf, parents="vacc_event", base_p=0.001,
          rr_vacc=4) +
  node_td("vacc", type="time_to_event", prob_fun=prob_vacc,
          event_duration=Inf, parents="meds_event", base_p=0.0005,
          rr_meds=5) +
  node_td("influenza", type="time_to_event", prob_fun=prob_influ,
          event_duration=20, parents=c("mac", "vacc_event", "meds_event"),
          base_p=0.001, rr_mac=1.5, rr_vacc_mac=0.8, rr_vacc_nonmac=0.5,
          rr_meds=4)
plot(dag)
```

```{r}
set.seed(32457656)
sim <- sim_discrete_time(dag, n_sim=100000, max_t=365)
```

## Cox Beispiel (ohne Adjustierung)

```{r}
dmod <- sim2data(sim, to="start_stop", target_event="influenza",
                 overlap=TRUE, keep_only_first=TRUE)

mod <- coxph(Surv(start, stop, influenza) ~ mac + vacc + mac*vacc, data=dmod)
summary(mod)
```

## Cox Beispiel (mit Adjustierung)

```{r}
mod <- coxph(Surv(start, stop, influenza) ~ mac + vacc + mac*vacc + meds,
             data=dmod)
summary(mod)
```

## Matching Beispiel (ohne Adjustierung)

```{r}
d_treat <- get_event_times(sim, "vacc")
d_influ <- get_event_times(sim, "influenza")
d_meds <- get_event_times(sim, "meds")
d_baseline <- sim$data[, c(".id", "mac"), with=FALSE]

dlist <- list(d_influ)
names(dlist) <- c("influenza")
d_inclusion <- list2start_stop(dlist, n=nrow(d_baseline), max_t=365,
                               durations=20)
d_inclusion <- d_inclusion[influenza==FALSE]

d_match <- td_matching(id=".id", time=".time", d_treat=d_treat,
                       d_event=d_influ, d_baseline=d_baseline,
                       keep_all_columns=TRUE, d_inclusion=d_inclusion,
                       replace_at_t=FALSE, verbose=FALSE)

mod <- coxph(Surv(event_time, status) ~ .treat + mac + .treat*mac,
             data=d_match)
summary(mod)
```

## Matching Beispiel (mit Adjustierung)

```{r}
d_match <- add_previous_event_time(data=d_match, id=".id", time=".time",
                                   d_prev=d_meds, duration=Inf, name="meds")

mod <- coxph(Surv(event_time, status) ~ .treat + mac + .treat*mac + meds,
             data=d_match)
summary(mod)
```

## Monte-Carlo Vergleich

```{r}
set.seed(2432454)

out <- sim_comp(
  dag=dag,
  n_sim=4000,
  n_repeats=500,
  max_t=365,
  n_cores=8,
  if_lt_n_at_t="warn",
  formula_cox="Surv(start, stop, influenza) ~ mac + vacc + mac*vacc + meds",
  formula_matching="Surv(event_time, status) ~ mac + .treat + mac*.treat + meds",
  td_variables=list(list(name="meds", duration=Inf)),
  progressbar=FALSE
)

true_rr <- c("mac"=1.5, "vacc"=0.5, "mac*vacc"=1.6, "meds"=4)
plot_bias(out, true_rr)
```
