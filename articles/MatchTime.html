<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>An Introduction to Time-Dependent Matching with MatchTime • MatchTime</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="An Introduction to Time-Dependent Matching with MatchTime">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">MatchTime</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item"><a class="nav-link" href="../articles/MatchTime.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/creating_start_stop_data.html">Creating and Dealing with Start-Stop Data in R</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/RobinDenz1/MatchTime/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>An Introduction to Time-Dependent Matching with MatchTime</h1>
                        <h4 data-toc-skip class="author">Robin Denz</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/RobinDenz1/MatchTime/blob/main/vignettes/MatchTime.rmd" class="external-link"><code>vignettes/MatchTime.rmd</code></a></small>
      <div class="d-none name"><code>MatchTime.rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Time-dependent matching is a very versatile method to perform causal
inference based analysis with longitudinal data. In this type of
matching, individuals who switch from “control” to the “treatment” at
some point in time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
are matched to one or more (usually similar) individuals who are still
under “control” conditions at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
This point in time is then used as the “baseline” or “time-zero” for all
individuals included in this way. The time from this artificial
inclusion time until the occurrence of some time-dependent event is then
usually used as an outcome, mimicking a prospective randomized
controlled trial with staggered entry of participants (Thomas et
al. 2020). There are multiple different versions of time-dependent
matching that follow these general principles, such as <em>balanced risk
set matching</em> (Li et al. 2001), <em>time-dependent propensity score
matching</em> (Lu 2005), <em>time-dependent prognostic score
matching</em> (Hansen 2008; He et al. 2020), <em>time-dependent
double-score matching</em> (He et al. 2020) and <em>time-dependent
greedy matching</em> (Gran et al. 2010). More information about the
methods themselves is given in the documentation pages and the cited
literature. To get a general overview, we also highly recommend the
excellent review article by Thomas et al. (2020).</p>
<p>The <code>MatchTime</code> package aims to implement all forms of
time-dependent matching for binary treatment variables in a consistent
fashion. The package is designed to be as similar as possible to the
<code>MatchIt</code> package (Ho et al. 2011), which is probably the
most widely used piece of software to conduct regular matching (without
time-dependent treatments). In fact, since most time-dependent matching
methods require regular matching at each considered point in time, the
<code>MatchTime</code> package has built-in support for
<code>MatchIt</code> (Ho et al. 2011) and all of its’ functionality.
This vignette gives a first small introduction to the general workflow
when using <code>MatchTime</code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RobinDenz1/MatchTime" class="external-link">MatchTime</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-datatable.com" class="external-link">data.table</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/therneau/survival" class="external-link">survival</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://kosukeimai.github.io/MatchIt/" class="external-link">MatchIt</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ngreifer.github.io/cobalt/" class="external-link">cobalt</a></span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="an-example-the-stanford-heart-transplant-program">An Example: The Stanford Heart Transplant Program<a class="anchor" aria-label="anchor" href="#an-example-the-stanford-heart-transplant-program"></a>
</h2>
<p>To better illustrate the features of this package, we will re-analyze
real data that is publicly available. In particular, we will use the
<code>heart</code> dataset from the famous <code>survival</code> R
package here. Contrary to other packages implementing forms of
time-dependent matching, the <code>MatchTime</code> package requires the
input <code>data</code> to be in the <em>start-stop</em> format. This
means that for each individual, all information should be encoded in
form of time intervals in which the value of the included covariates
does not change. This allows users to perform the matching in discrete
and continuous time, without any need for equally spaced times of
measurement. A more detailed explanation is given in the documentation
pages and the associated vignette (see
<code><a href="../articles/creating_start_stop_data.html">vignette("creating_start_stop_data", package="MatchTime")</a></code>).</p>
<p>The <code>heart</code> dataset can be accessed using:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"heart"</span>, package<span class="op">=</span><span class="st">"survival"</span><span class="op">)</span></span></code></pre></div>
<p>This dataset has been pre-processed to be in the start-stop format
and contains information of 103 patients on the waiting list for the
Stanford heart transplant program (Crowley and Hu 1977). The first few
rows of the data look like this:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">heart</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   start stop event        age      year surgery transplant id</span></span>
<span><span class="co">## 1     0   50     1 -17.155373 0.1232033       0          0  1</span></span>
<span><span class="co">## 2     0    6     1   3.835729 0.2546201       0          0  2</span></span>
<span><span class="co">## 3     0    1     0   6.297057 0.2655715       0          0  3</span></span>
<span><span class="co">## 4     1   16     1   6.297057 0.2655715       0          1  3</span></span>
<span><span class="co">## 5     0   36     0  -7.737166 0.4900753       0          0  4</span></span>
<span><span class="co">## 6    36   39     1  -7.737166 0.4900753       0          1  4</span></span></code></pre>
<p>In this dataset, the columns called <code>start</code> and
<code>stop</code> are used to define the right-open time-intervals,
while the <code>id</code> column is used to identify which rows belong
to which individual. The <code>event</code> column contains the binary
event indicator that is 0 if no event occurred and 1 if an event
occurred exactly at the <code>stop</code> value. Additionally, the
dataset contains four covariates, <code>age</code> (the age of the
individual in years - 48 years), the <code>year</code> of acceptance (in
years after the first November 1967), <code>surgery</code> (whether the
person had a prior bypass surgery) and whether the person received a
<code>transplant</code> or not.</p>
<p>Here, individual with <code>id = 1</code> has never received a
<code>transplant</code> and experienced an event after 50 time units.
Since no covariate values change for this person, he or she only has one
row in the dataset. The individual with <code>id = 4</code> on the other
hand received a <code>transplant</code> at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>36</mn></mrow><annotation encoding="application/x-tex">t = 36</annotation></semantics></math>
and experienced an event three time units later at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>39</mn></mrow><annotation encoding="application/x-tex">t = 39</annotation></semantics></math>
with no other covariate changes inbetween. He or she therefore occupies
two rows in this dataset.</p>
<p>For exemplary purposes, we will use the <code>transplant</code>
variable as the treatment we are interested in and will consider the
three other covariates (<code>age</code>, <code>years</code> and
<code>surgery</code>) as confounders. We will pretend that the goal is
to estimate the causal effect of the <code>transplant</code> on the
<code>event</code>. Since <code>transplant</code> is a binary
time-varying variable and the dataset is already in the required format,
this is a neat example to introduce the capabilities of
<code>MatchTime</code>. The results should, however, not be taken too
seriously as the analysis is only performed for pedagogical
purposes.</p>
</div>
<div class="section level2">
<h2 id="performing-the-matching">Performing the Matching<a class="anchor" aria-label="anchor" href="#performing-the-matching"></a>
</h2>
<p>We can perform balanced risk set matching using nearest neighbor
matching at each point in time using the following
<code><a href="../reference/match_time.html">match_time()</a></code> call:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">12345</span><span class="op">)</span></span>
<span></span>
<span><span class="va">m_out</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/match_time.html">match_time</a></span><span class="op">(</span><span class="va">transplant</span> <span class="op">~</span> <span class="va">age</span> <span class="op">+</span> <span class="va">surgery</span>,</span>
<span>                    id<span class="op">=</span><span class="st">"id"</span>,</span>
<span>                    outcomes<span class="op">=</span><span class="st">"event"</span>,</span>
<span>                    data<span class="op">=</span><span class="va">heart</span>,</span>
<span>                    method<span class="op">=</span><span class="st">"brsm"</span>,</span>
<span>                    match_method<span class="op">=</span><span class="st">"nearest"</span>,</span>
<span>                    replace_over_t<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">m_out</span></span></code></pre></div>
<pre><code><span><span class="co">## A match_time object</span></span>
<span><span class="co">##  - method: balanced risk set matching</span></span>
<span><span class="co">##  - match-method: 1:1 nearest neighbor matching (using matchit())</span></span>
<span><span class="co">##  - controls: Replacing controls only over time</span></span>
<span><span class="co">##  - cases: Using all cases</span></span>
<span><span class="co">##  - number of obs.: 103 (original), 138 (matched)</span></span>
<span><span class="co">##  - target estimand: ATT</span></span>
<span><span class="co">##  - covariates: age, surgery</span></span></code></pre>
<p>Here, we first set a seed for the pseudo-random number generator to
make the results replicable. This is required, because the selection of
controls is based on randomness. Afterwards we can directly call the
main function of this package to do the matching for us. The
<code>formula</code> argument is used to define what parts of
<code>data</code> should be matched. We define the treatment variable by
putting it on the LHS of the formula and the confounders to be matched
on by putting them on the RHS. Since there are multiple rows per person,
we also have to tell the function how to identify these persons using
the <code>id</code> argument. Additionally, we use the
<code>outcomes</code> argument to specify which variables should be
coded as time-to-event outcomes to allow an easier analysis later.</p>
<p>Next, the <code>method</code> argument controls the time-dependent
matching method, which is set to <em>balanced risk set matching</em> (Li
et al. 2001) here, while the <code>match_method</code> argument
specifies the actual matching algorithm used when matching controls to
the cases at each point in time. Here we set
<code>match_method="nearest"</code>, which means that nearest neighbor
matching, as implemented in <code><a href="https://kosukeimai.github.io/MatchIt/reference/matchit.html" class="external-link">MatchIt::matchit()</a></code> will be
used. Finally, we set <code>replace_over_t=TRUE</code> to allow controls
to be re-used over multiple points in time. Note that, similar to
<code><a href="https://kosukeimai.github.io/MatchIt/reference/matchit.html" class="external-link">matchit()</a></code>, each <code>method</code> may have additional
arguments or caveats that are documented in their own documentation
page.</p>
</div>
<div class="section level2">
<h2 id="inspecting-and-visualizing-the-matching-process">Inspecting and Visualizing the Matching Process<a class="anchor" aria-label="anchor" href="#inspecting-and-visualizing-the-matching-process"></a>
</h2>
<p>Because the <code><a href="../reference/match_time.html">match_time()</a></code> function basically does
everything automatically, it might be difficult to understand what
exactly actually happened at first. Luckily, the <code>MatchTime</code>
package includes multiple functions to visualize the matching process
and the results.</p>
<p>First, it always makes sense to take a look at the number of matches
and controls throughout the matching process. This can be done easily
using the <code><a href="../reference/plot.match_time.html">plot.match_time()</a></code> function:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">m_out</span><span class="op">)</span></span></code></pre></div>
<p><img src="MatchTime_files/figure-html/unnamed-chunk-5-1.png" width="643.2"></p>
<p>In addition to the cumulative number of cases over time and the
cumulative number of matched controls over time, it also includes the
number of potential controls that would have been available at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
Note that if you use the <code>inclusion</code> argument, this number
might not be non-increasing over time. Here we can see that the majority
of the matching was done in the first 100 time units. Only few
individuals were matched later. We can also see that the number of cases
and controls is exactly the same over the entire time, which means that
we always found a control for a case (remember that we used 1:1 matching
here).</p>
<p>Next, we may also create a flowchart to describe the matching process
more succintly. This can also be done easily, using the
<code><a href="../reference/plot_flowchart.html">plot_flowchart()</a></code> function:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot_flowchart.html">plot_flowchart</a></span><span class="op">(</span><span class="va">m_out</span><span class="op">)</span></span></code></pre></div>
<p><img src="MatchTime_files/figure-html/unnamed-chunk-6-1.png" width="864"></p>
<p>In this case, we started with the full set of 103 individuals. All of
them received the <code>transplant</code> after
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t = 0</annotation></semantics></math>,
so they could have theoretically been used as a control at some point in
time (e.g. they are “potential controls”). Only 69 of these individuals
ever received the <code>transplant</code>, meaning we had 69 potential
cases that we could try to match. Since we did not define any inclusion
criteria, there was no further subsetting here. The algorithm was able
to match a control to all of these individuals. We therefore end up with
69 cases and 69 matched controls. Note that in this case, because we set
<code>replace_over_t=TRUE</code>, 17 individuals were selected as
control more than once, while 63 individuals were never selected. If we
had set <code>replace_over_t=FALSE</code>, some individuals would not
have gotten a control, because of the different lenghts of follow-up
time.</p>
<p>We can further visualize the exact time-intervals included for each
person by using the <code><a href="../reference/plot_timeline.html">plot_timeline()</a></code> function. Below we show
the included time-lines for the first 7 individuals who were selected
into the matching process.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot_timeline.html">plot_timeline</a></span><span class="op">(</span><span class="va">m_out</span>, include<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span>, <span class="fl">5</span>, <span class="fl">6</span>, <span class="fl">7</span><span class="op">)</span>,</span>
<span>              id_type<span class="op">=</span><span class="st">"id"</span><span class="op">)</span></span></code></pre></div>
<p><img src="MatchTime_files/figure-html/unnamed-chunk-7-1.png" width="643.2"></p>
<p>Here we can see that individuals with <code>id %in% c(2, 5, 6)</code>
were never selected, whereas <code>id = 4</code> was selected as control
twice and included as a case (for a very short amount of time).</p>
</div>
<div class="section level2">
<h2 id="inspecting-covariate-balance">Inspecting Covariate Balance<a class="anchor" aria-label="anchor" href="#inspecting-covariate-balance"></a>
</h2>
<p>If we rely solely on the matching process to achieve the covariate
balance at baseline (e.g. we do not plan any further covariate
adjustments), it is crucial to inspect whether this covariate balance
between the groups was actually achieved. A first look can be gained
using the <code><a href="../reference/summary.match_time.html">summary.match_time()</a></code> method:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">m_out</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Call:</span></span>
<span><span class="co">## match_time(formula = transplant ~ age + surgery, data = heart, </span></span>
<span><span class="co">##     id = "id", outcomes = "event", method = "brsm", replace_over_t = TRUE, </span></span>
<span><span class="co">##     match_method = "nearest")</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Summary of Balance for Matched Data at Baseline:</span></span>
<span><span class="co">##         Means Treated Means Control Std. Mean Diff. Var. Ratio  eCDF Mean</span></span>
<span><span class="co">## age        -1.9667292    -3.0001686      0.11643458  0.7293539 0.02242926</span></span>
<span><span class="co">## year        3.5988850     3.5364700      0.03530218  0.9351385 0.02601711</span></span>
<span><span class="co">## surgery     0.1884058     0.1449275      0.11118740         NA 0.04347826</span></span>
<span><span class="co">##           eCDF Max</span></span>
<span><span class="co">## age     0.07246377</span></span>
<span><span class="co">## year    0.08695652</span></span>
<span><span class="co">## surgery 0.04347826</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Sample Sizes:</span></span>
<span><span class="co">##           Controls Treated All</span></span>
<span><span class="co">## Matched         69      69 138</span></span>
<span><span class="co">## Unmatched       19       0  19</span></span>
<span><span class="co">## Included       103      69 103</span></span>
<span><span class="co">## Supplied       103      69 103</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Points in Time:</span></span>
<span><span class="co">## Matching was performed at 43 unique points in time between 1 and 310.</span></span></code></pre>
<p>We could also use the excellent <code>cobalt</code> package to obtain
similar statistics in a more organized fashion:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://ngreifer.github.io/cobalt/reference/bal.tab.html" class="external-link">bal.tab</a></span><span class="op">(</span><span class="va">m_out</span>, stats<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mean.diffs"</span>, <span class="st">"variance.ratios"</span>,</span>
<span>                       <span class="st">"ks.statistics"</span>, <span class="st">"ovl.coefficients"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="text-decoration: underline;">Balance Measures</span></span></span>
<span><span class="co">##            Type Diff.Un V.Ratio.Un  KS.Un OVL.Un</span></span>
<span><span class="co">## age     Contin.  0.1164     0.7294 0.0725 0.0465</span></span>
<span><span class="co">## year    Contin.  0.0353     0.9351 0.0870 0.0269</span></span>
<span><span class="co">## surgery  Binary  0.0435          . 0.0435 0.0435</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## <span style="text-decoration: underline;">Sample sizes</span></span></span>
<span><span class="co">##     FALSE TRUE</span></span>
<span><span class="co">## All    69   69</span></span></code></pre>
<p>Or present the results in form of a <code><a href="https://ngreifer.github.io/cobalt/reference/love.plot.html" class="external-link">love.plot()</a></code>:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://ngreifer.github.io/cobalt/reference/love.plot.html" class="external-link">love.plot</a></span><span class="op">(</span><span class="va">m_out</span><span class="op">)</span></span></code></pre></div>
<p><img src="MatchTime_files/figure-html/unnamed-chunk-10-1.png" width="643.2"></p>
<p>Note that both <code><a href="https://ngreifer.github.io/cobalt/reference/bal.tab.html" class="external-link">bal.tab()</a></code> and <code><a href="https://ngreifer.github.io/cobalt/reference/love.plot.html" class="external-link">love.plot()</a></code>
only show the balance statistics for the adjusted data here. This is in
contrast to how these functions work when used on regular
<code>matchit</code> objects created using
<code><a href="https://kosukeimai.github.io/MatchIt/reference/matchit.html" class="external-link">MatchIt::matchit()</a></code>. The reason for this discrepancy is,
that without the time-dependent matching there is no “baseline” or other
natural point in time to use in order to get values for an “unadjusted”
covariate balance. This is not an issue though, since we are usually
only interested in judging whether the covariate balance is sufficient
after adjustment anyways. In this particular case, the covariate balance
seems fine.</p>
</div>
<div class="section level2">
<h2 id="analyzing-matched-data">Analyzing Matched Data<a class="anchor" aria-label="anchor" href="#analyzing-matched-data"></a>
</h2>
<p>The <code>m_out$data</code> object of our previously created
<code>match_time</code> object already constitutes an almost finished
dataset that might be tempting to use for further analysis. In many
cases this is not a problem. It is, however, safer and thereby
recommended to use the <code><a href="../reference/get_match_data.html">get_match_data()</a></code> function instead to
get the output data:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_match_data.html">get_match_data</a></span><span class="op">(</span><span class="va">m_out</span><span class="op">)</span></span></code></pre></div>
<p>This is similar to the <code><a href="https://kosukeimai.github.io/MatchIt/reference/match_data.html" class="external-link">get_matches()</a></code> or
<code><a href="https://kosukeimai.github.io/MatchIt/reference/match_data.html" class="external-link">match_data()</a></code> functions from the <code>MatchIt</code>
package (although using a different name to avoid name conflicts). It
automatically removes all unmatched individuals and returns the entire
dataset as needed for further analysis. The first few rows of the output
look like this:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">m_data</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Key: &lt;id&gt;</span></span>
<span><span class="co">##       id .id_new .id_pair .treat .treat_time .next_treat_time .weights</span></span>
<span><span class="co">##    &lt;num&gt;   &lt;int&gt;   &lt;char&gt; &lt;lgcl&gt;       &lt;num&gt;            &lt;num&gt;    &lt;num&gt;</span></span>
<span><span class="co">## 1:     1      72       36  FALSE          27               NA        1</span></span>
<span><span class="co">## 2:     3       1        1   TRUE           1               NA        1</span></span>
<span><span class="co">## 3:     4      10        5  FALSE           2               36        1</span></span>
<span><span class="co">## 4:     4      64       32  FALSE          23               36        1</span></span>
<span><span class="co">## 5:     4      89       45   TRUE          36               NA        1</span></span>
<span><span class="co">## 6:     7     107       54   TRUE          51               NA        1</span></span>
<span><span class="co">##           age      year surgery event_status event_time</span></span>
<span><span class="co">##         &lt;num&gt;     &lt;num&gt;   &lt;num&gt;       &lt;lgcl&gt;      &lt;num&gt;</span></span>
<span><span class="co">## 1: -17.155373 0.1232033       0         TRUE         23</span></span>
<span><span class="co">## 2:   6.297057 0.2655715       0         TRUE         15</span></span>
<span><span class="co">## 3:  -7.737166 0.4900753       0        FALSE         34</span></span>
<span><span class="co">## 4:  -7.737166 0.4900753       0        FALSE         13</span></span>
<span><span class="co">## 5:  -7.737166 0.4900753       0         TRUE          3</span></span>
<span><span class="co">## 6:   2.869268 0.7802875       0         TRUE        624</span></span></code></pre>
<p>A detailed description about the contents of each column is given in
the <code><a href="../reference/match_time.html">?match_time</a></code> documentation page. This final dataset may
now be analyzed using standard analysis techniques for time-to-event
endpoints. For example, we could plot standard Kaplan-Meier curves:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/survfit.html" class="external-link">survfit</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">event_time</span>, <span class="va">event_status</span><span class="op">)</span> <span class="op">~</span> <span class="va">.treat</span>, data<span class="op">=</span><span class="va">m_data</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="MatchTime_files/figure-html/unnamed-chunk-13-1.png" width="643.2"></p>
<p>A similarly popular alternative would be a Cox proportional hazards
model:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">event_time</span>, <span class="va">event_status</span><span class="op">)</span> <span class="op">~</span> <span class="va">.treat</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/strata.html" class="external-link">strata</a></span><span class="op">(</span><span class="va">.treat_time</span><span class="op">)</span>, data<span class="op">=</span><span class="va">m_data</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Call:</span></span>
<span><span class="co">## coxph(formula = Surv(event_time, event_status) ~ .treat + strata(.treat_time), </span></span>
<span><span class="co">##     data = m_data)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##   n= 138, number of events= 67 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">##               coef exp(coef) se(coef)      z Pr(&gt;|z|)</span></span>
<span><span class="co">## .treatTRUE -0.1755    0.8390   0.3398 -0.517    0.605</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##            exp(coef) exp(-coef) lower .95 upper .95</span></span>
<span><span class="co">## .treatTRUE     0.839      1.192     0.431     1.633</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Concordance= 0.543  (se = 0.069 )</span></span>
<span><span class="co">## Likelihood ratio test= 0.27  on 1 df,   p=0.6</span></span>
<span><span class="co">## Wald test            = 0.27  on 1 df,   p=0.6</span></span>
<span><span class="co">## Score (logrank) test = 0.27  on 1 df,   p=0.6</span></span></code></pre>
<p>Here we can see a hazard ratio that is smaller than 1, indicating a
slight protective effect of the transplantation on the event
probability, although this hazard ratio of course has a rather large
confidence interval.</p>
</div>
<div class="section level2">
<h2 id="going-further">Going Further<a class="anchor" aria-label="anchor" href="#going-further"></a>
</h2>
<p>This vignette is only meant to give a brief overview of the workflow
and capabilities of the package. It therefore deliberately left out some
important considerations, such as the target estimand, censoring schemes
and caveats when analyzing the data. It also only showcases one kind of
time-dependent matching. Please consult the documentation and the other
vignettes of this package for further information.</p>
</div>
<div class="section level2">
<h2 id="literature">Literature<a class="anchor" aria-label="anchor" href="#literature"></a>
</h2>
<p>Thomas, Laine E., Siyun Yang, Daniel Wojdyla, and Douglas E. Schaubel
(2020). “Matching with Time-Dependent Treatments: A Review and Look
Forward”. In: Statistics in Medicine 39, pp. 2350-2370.</p>
<p>Li, Yunfei Pail, Kathleen J. Propert, and Paul R. Rosenbaum (2001).
“Balanced Risk Set Matching”. In: Journal of the American Statistical
Association 96.455, pp. 870-882.</p>
<p>Lu, Bo (2005). “Propensity Score Matching with Time-Dependent
Covariates”. In: Biometrics 61.3, pp. 721-728.</p>
<p>Hansen, Ben B. (2008). “The Prognostic Analogue of the Propensity
Score”. In: Biometrika 95.2, pp. 481-488.</p>
<p>He, Kevin, Yun Li, Panduranga S. Rao, Randall S. Sung, and Douglas E.
Schaubel (2020). “Prognostic Score Matching Methods for Estimating the
Average Effect of a Non-Reversible Binary Time-Dependent Treatment on
the Survival Function”. In: Lifetime Data Analysis 26, pp. 451-470.</p>
<p>Gran, Jon Michael, Kjetil Røysland, Marcel Wolbers, Vanessa Didelez,
Jonathan A. C. Sterne, Bruno Ledergerber, Hansjakob Furrer, Viktor von
Wyl, and Odd O. Aalen (2010). “A Sequential Cox Approach for Estimating
the Causal Effect of Treatment in the Presence of Time-Dependent
Confounding Applied to Data from the Swiss HIV Cohort Study”. In:
Statistics in Medicine 29, pp. 2757-2768.</p>
<p>Ho, Daniel, Kosuke Imai, Gary King and Elizabeth A. Stuart (2011).
“MatchIt: Nonparametric Preprocessing for Parametric Causal Inference”.
In: Journal of Statistical Software 42.8.</p>
<p>Crowley, John and Marie Hu (1977). “Covariance Analysis of Heart
Transplant Survival Data”. In: Journal of the American Statistical
Association 72.357, pp. 27-36.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Robin Denz.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
